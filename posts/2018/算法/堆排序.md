# 堆的算法
在算法中，堆是一种数据结构，它是一颗二叉树，如下图所示：  
![person_pb2](../images/堆1.jpeg)

我们常说的堆一般指的是二叉堆，即用二叉树来构建的一种数据结构。  
当一颗二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序  
能够用堆有序的完全二叉树排序的元素就是二叉堆

会采用数组来存放元素，其中，树的每一层都会被填满，除了最后一层，最后一层会从一个节点的左子树开始填。堆采用数组的方式来存储，如`[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]`。给定数组A，其树的根为A[1]，给定某个节点的下标为i，则左儿子和右儿子的下边可以简单的被计算出来:
1. left：i * 2
2. right：(i * 2) + 1
3. parent：i / 2，向下取整

观察上面的计算公式，我们知道在计算机里，可以通过左移和右移来计算与2的乘法和除法，因此也有了如下公式：
1. left：i的二进制左移1位
1. right：i的二进制左移1位并在低位中+1
1. parent：i的二进制右移1位得到i/2

**高度为h的堆中，最多和最好的元素个数？**  
最多元素的情况就是左右子节点全部存在，每一层都会基于上一层的节点个数*2：  
1 + 1 * 2 + 1 * 2 * 2 + ... + 1 * 2^(h) = 1 + 2 + 2^2 + ... + 2^h = 2^(h+1) - 1

最少元素的情况就是最后一层一直一个节点，可以退化成求(h-1)高度的最大元素个数+1，即为2^h

**含N个元素的堆的高度为多少？**  
高度为logN，其中log为以2为底

**高度为h，至多有多少个节点？**  
至多有n/(2^(h+1))，向下取整

二叉堆包含两种：最大堆和最小堆。
1. 最大堆：A[parent(i)] >= A[i]
2. 最小堆：A[parent(i)] <= A[i]

## 堆算法之上浮
当堆中的某个元素发生变化，导致比父元素大时，需要重新调整堆，这时可以采用上浮的方式，逐次判断父节点和变化元素的大小，并且进行交换
```go
func swim(data []int) {
	i := len(data) - 1
	for i > 1 && data[i/2] < data[i] {
		data[i/2], data[i] = data[i], data[i/2]
		i = i / 2
	}
}
```

## 堆算法之下沉
当堆中的某个元素发生变化，导致比子元素小时，需要重新调整堆，这时可以采用下沉的方式，和自己的两个子节点中较大者进行交换
```go
func sink(data []int, n, index int) {
	for {
		maxIndex := index
		if index*2 <= n && data[index] < data[index*2] {
			maxIndex = index * 2
		}
		if index*2+1 <= n && data[maxIndex] < data[index*2+1] {
			maxIndex = index*2 + 1
		}

		if maxIndex == index {
			break
		}

		data[maxIndex], data[index] = data[index], data[maxIndex]
		index = maxIndex
	}
}
```

## 分析
当需要插入新元素时，可以将元素加到数组的末尾，然后将这个元素上浮到合适的位置。

当需要删除最大元素时，从顶端删去最大的元素，将数组的最后一个元素放到顶端，然后不断下沉即可

一个包含n个节点的完全二叉树，树的高度不会超过*logn*，不管是插入还是删除节点，都是一个堆化的过程，它们会沿着树的路径不断（不论从下到上，还是从上到下）对比和交换，这个对比和交换的次数最大值就是树的高度，而一颗完全二叉树的高度为logn，因此O(logn)。

# 堆排序
堆排序简单来说，就是利用堆的性质来进行排序。

堆排序是一种就地排序，在任何时候数组中只有常数个元素存储在输入数组之外。  
运行时间：O(nlogn)

我们知道堆的高度为O(logN)，下沉时间顶多为O(logN)，即O(h)，h为堆的高度

将一个无序的数组序列进行堆排序，有两个步骤：
1. 将数组构建成一个满足二叉堆性质的数组，即建堆
2. 对这个二叉堆进行排序，即排序

如果是递增排序，可以采用建立最大堆的方式；如果是递减排序，可以采用建立最小堆的方式。

这里我们做的是递增排序，也即最大堆的方式

另外我们构建的数组中，数据会从下标为1处开始存储，这样方便我们计算父子节点。

## 建堆
建堆是指将数组中的数据最终变成符合堆的特性的顺序，一般采用自底向上的方式来建堆，即从后往前处理数组的数据，不断通过下沉的方式调整数据，建堆的运行时间为O(N)
```go
func buildHeap(data []int) {
	length := len(data)
	for i := length / 2; i >= 1; i-- {
		sink(data, i)
	}
}
```

![WX20180803-135908](../images/WX20180803-135908.png)

这种方式建堆会从n/2开始，而n/2+1到n都是叶子节点，也就相当于我们直接忽略最后一层，从倒数第二层开始建堆。

每个节点堆化中比较和交换的次数和高度成正比。

```
S1 = 1 * h + 2 * (h-1) + 2^2 * (h-2) + ... + 2^k * (h - k) + ... + 2^(h-1) * 1

# 将等式两边都乘以2，得到
S2 =         2 * h    +  2^2 *(h-1) + ... + 2^k * (h - k + 1)... + 2^(h-1) * 2 + 2^(h) * 1

S = S2 - S1 = h + 2 + 2^2 + 2^3 + ... + 2^k + ... + 2^h-1 + 2^h
  = h + (2^h - 2) + 2^h
  = 2^(h+1) + h - 2

h = logn
S = 2^(logn+1) + logn - 2
  = O(n)
```

由此可知，堆化的时间复杂度为O(n)

## 排序
堆化之后的数据，堆顶已经是最大的元素了，这时我们按照如下流程进行元素调整，最终让有元素有序。

排序过程：
1. 将第一个元素和堆的最后一个元素交换，将最后一个元素放到堆顶，必然会引起堆结构被破坏，此时通过下沉方式调整堆结构。
2. 取出此时的堆顶元素，和倒数第二个元素交换，再次调整。这方式有点像在删除元素
3. 不断重复，知道再无元素可以取。此时会构建出一个递增排序的新堆。

简单来说，堆排序是由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。

```go
func sort(data []int) {
	// 堆化
	buildHeap(data)

	length := len(data)
	k := length
	for k > 1 {
		data[1], data[k] = data[k], data[1]
		k--
		sink(data, k, 1)
	}
}
```
运行时间：
构建初始堆+堆元素交换 = O(N) + O(swap)  
堆元素交换运行时间=log(N-1) + log(N-2) + ... + log(1) = O(NlogN)

因此运行时间为 = O(N) + O(NlogN) = O(NlogN)

## 结论
一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

堆排序时一种原地排序，没有利用额外的空间。

我们知道快速排序的时间复杂度也是O(NlogN)，但是在实际使用中，会偏向于使用快速排序，而不是堆排序，这是因为：
1. 堆排序对数据的访问方式不是很友好，没法充分利用CPU缓存。例如我们建堆的过程中，数据都是跳着访问的，如1，2，4，8，但是快排的话，访问都是局部的顺序访问。
2. 对于同样的数据，在排序的过程中，堆排序的数据交换次数要多于快速排序。在建堆的过程中，会打乱数据的有序性，可能会导致本来已经有序的数据，建堆后就变得无序了。

## 堆的应用
### 优先级队列
队列的特性也是先进先出，优先级队列也是一种队列，但它不是先进先出，而是优先级高的先出。

可以采用堆来实现优先级队列，往优先级队列中插入元素，相当于往堆中插入元素，优先级最高的可以从堆顶获取。

优先级队列在很多场合都会用到

#### 定时器队列
项目中经常会使用到定时器，在定时器维护很多定时任务，每个任务都设定了一个时间，到达一定的时间就会执行特定的任务。

定时器需要定时的不断扫描任务，发现到达出发时间就得执行任务，那么如何定时扫描才能更搞笑呢？

最传统的方式就是每隔一个很短的时间，如1s，就扫描所有任务，但是这种方式效率很低，因为有可能大部分任务都还没到时间时间，但是却需要浪费大部分时间来扫描，而且如果列表很大的话扫描也会很耗性能。

我们可以采用优先级队列来解决这个问题，这个优先队列可以是用堆实现的。

先按照任务设定的执行时间，将这些任务存储在优先队列中，队列首部（小顶堆的堆顶）存储的是最先执行的任务。

然后取出队列首部的任务，得到任务执行的时间点，与当前时间做比较，两者的差值为T，那么在这段T时间里，定时器可以不用做任何事情，等到T秒后就开始执行这个队首的任务，将它从队列首部移除，获取新的首部（堆的话，要重新堆化），得到新的时间，同理再和当前时间做比较，计算距离下次执行的时间。

通过这种方式不需要不断每秒轮训队列，而且每次只需要获取一个任务。

#### 合并有序的小文件
假设我们已经有100个小文件，每个文件大小为100MB，每个文件存储的是排好序的字符串。现在想将这100个文件合并成一个有序的大文件。

第一个方法，可以先从100个文件中，都取出第一个元素放入一个数组中，然后获取数组中最小的元素，并且将其从数组移除，然后将它加入大文件中。接下来继续从这个被移除元素所在的小文件中挑选第二个元素，放入数组，重复上述过程。这样最终大文件的就是有序的。

但是这种方式效率太低了，也相对浪费空间一些，我们可以采用优先级队列改善。

同样还是从100个文件中各取出第一个元素，然后构建成一个小顶堆，那么堆顶就是最小的元素，删除堆顶的元素，将其加入大文件中。

调整堆，然后从被删除元素所在的小文件中取出第二个元素，加入堆中，重新调整堆，再删除堆顶的元素，加入大文件中。不断重复这个过程。

这种方式，删除元素和加入元素都各需堆化一次，时间复杂度都为O(logn)，这里的n是堆中的元素，即100。存储空间比用数组的方式得到很大节省。

## 获取TOP K的数据
有一个很大的集合，包含元素n个，如何获取前k大的元素?

首先我们可以先从集合中取出k个元素，将这k个元素构建为小顶堆，堆顶是这k个元素中最小的一个。

然后开始遍历集合中剩余的元素，取出的每个元素和堆顶的元素比较，如果比堆顶的小，则忽略这个元素，继续遍历。  
如果比堆顶元素大，则将堆顶元素删除，将从集合取出的元素放入堆顶，然后下沉重新堆化。

最终遍历完集合后，堆中的k个元素就是集合中前k大的元素了。

遍历数组需要O(n)，一次堆化的时间复杂度为O(logk)，最坏情况下，每次遍历都需要堆化，此时时间复杂度为O(nlogn)

