# 设计模式

[toc]

## 创建型

### 单例模式

定义：一个类只允许创建一个对象（或者实例），这个类就是单例类，该设计模式叫单例设计模式，简称单例模式。

#### 饿汉模式

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log = newLogger("default logger")

func getLogger() *logger {
    return log
}
```

#### 懒汉模式

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var m sync.Mutex

func GetLogger() *logger {
    m.Lock()
    if log == nil {
        log = newLogger("default logger")
    }
    m.Unlock()

    return log
}
```

#### 饿汉与懒汉兼容

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var m sync.Mutex

func GetLogger() *logger {
    if log == nil {
        m.Lock()
        if log == nil {
            log = newLogger("hungry&lazy logger")
        }
        m.Unlock()
    }

    return log
}
```

#### 优雅实现

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var once sync.Once

func GetLogger() *logger {
    once.Do(func() {
        log = newLogger("singleton logger")
    })

    return log
}
```

### 工厂模式

#### 简单工厂

```go
type Human interface {
    Speak()
}

type HumanType uint

const (
    HumanTypeChinese HumanType = iota
    HumanTypeJapanese
    HumanTypeAmerican
)

type Chinese struct {
}

func (c Chinese) Speak() {
    fmt.Println("I speak Chinese")
}

type Japanese struct {
}

func (j Japanese) Speak() {
    fmt.Println("I speak Japanese")
}

type American struct {
}

func (a American) Speak() {
    fmt.Println("I speak American English")
}

type HumanFactory struct {
}

func (f HumanFactory) ProduceHuman(humanType HumanType) Human {
    if humanType == HumanTypeChinese {
        return &Chinese{}
    } else if humanType == HumanTypeJapanese {
        return &Japanese{}
    } else if humanType == HumanTypeAmerican {
        return &American{}
    } else {
        return nil
    }
}
```

#### 工厂方法

```go
type Human interface {
    Speak()
}

type HumanType uint
type HumanFactory func() Human

const (
    HumanTypeChinese HumanType = iota
    HumanTypeJapanese
    HumanTypeAmerican
)

type Chinese struct {
}

func (c Chinese) Speak() {
    fmt.Println("I speak Chinese")
}

func produceChinese() Human {
    return &Chinese{}
}

type Japanese struct {
}

func (j Japanese) Speak() {
    fmt.Println("I speak Japanese")
}

func produceJapanese() Human {
    return &Japanese{}
}

type American struct {
}

func (a American) Speak() {
    fmt.Println("I speak American English")
}

func produceAmerican() Human {
    return &American{}
}

var humanFactoryGenMap = map[HumanType]HumanFactory{
    HumanTypeChinese:  produceChinese,
    HumanTypeJapanese: produceJapanese,
    HumanTypeAmerican: produceAmerican,
}

func GetHumanFactory(humanType HumanType) HumanFactory {
    if h, ok := humanFactoryGenMap[humanType]; ok {
        return h
    }

    return nil
}

func HumanSpeak(humanType HumanType) {
    humanFactory := GetHumanFactory(humanType)
    if humanFactory == nil {
        return
    }

    human := humanFactory()
    human.Speak()
}
```

#### 抽象工厂

```go
type Human interface {
	Speak()
}

type HumanCreateFactory interface {
	ProduceHuman()
}

type ChineseFactory struct {
}

func (f ChineseFactory) ProduceHuman() Human {
	return &Chinese{}
}

type Chinese struct {
}

func (c Chinese) Speak() {
	fmt.Println("I speak Chinese")
}

type JapaneseFactory struct {
}

func (f JapaneseFactory) ProduceHuman() Human {
	return &Japanese{}
}

type Japanese struct {
}

func (j Japanese) Speak() {
	fmt.Println("I speak Japanese")
}

type AmericanFactory struct {
}

func (f AmericanFactory) ProduceHuman() Human {
	return &American{}
}

type American struct {
}

func (a American) Speak() {
	fmt.Println("I speak American English")
}
```

### 建造者模式

使用场景：当实例化对象的时候参数比较多，且参数之间存在依赖时可以考虑使用建造者模式。

```go
const (
    defaultMaxTotal = 10
    defaultMaxIdle  = 5
)

type ResourcePoolConfig struct {
    name     string
    maxTotal uint
    maxIdle  uint
    minIdle  uint
}

func newResourcePoolConfig(build *resourcePoolBuilder) *ResourcePoolConfig {
    return &ResourcePoolConfig{
        name:     build.name,
        maxTotal: build.maxTotal,
        maxIdle:  build.maxIdle,
        minIdle:  build.minIdle,
    }
}

type resourcePoolBuilder struct {
    name     string // 必填
    maxTotal uint   // 必填
    maxIdle  uint   // 必填
    minIdle  uint   // 选填
}

func NewResourcePoolBuilder() *resourcePoolBuilder {
    return &resourcePoolBuilder{
        maxTotal: defaultMaxTotal,
        maxIdle:  defaultMaxIdle,
    }
}

func (builder *resourcePoolBuilder) Build() (*ResourcePoolConfig, error) {
    if builder.name == "" {
        return nil, errors.New("name不能为空")
    }

    if builder.maxTotal == 0 {
        return nil, errors.New("maxTotal不能0")
    }

    if builder.maxIdle == 0 {
        return nil, errors.New("maxIdle不能0")
    }

    if builder.minIdle > builder.maxIdle {
        return nil, errors.New("minIdle不能大于maxIdle")
    }

    return newResourcePoolConfig(builder), nil
}

func (builder *resourcePoolBuilder) SetName(name string) *resourcePoolBuilder {
    builder.name = name
    return builder
}

func (builder *resourcePoolBuilder) SetMaxTotal(maxTotal uint) *resourcePoolBuilder {
    builder.maxTotal = maxTotal
    return builder
}

func (builder *resourcePoolBuilder) SetMaxIdle(maxIdle uint) *resourcePoolBuilder {
    builder.maxIdle = maxIdle
    return builder
}

func (builder *resourcePoolBuilder) SetMinIdle(minIdle uint) *resourcePoolBuilder {
    builder.minIdle = minIdle
    return builder
}
```

使用示例：

```go
func GetMysqlResourceConfig() (*ResourcePoolConfig,error) {
    resourceConfig, err := NewResourcePoolBuilder().
        SetName("mysql_pool_config").
        SetMaxTotal(50).
        SetMaxIdle(10).
        SetMinIdle(5).
        Build()
    if err != nil {
        return nil, err
    }
    
    return resourceConfig, nil
}
```

## 结构型

### 代理模式

```go
type Uploader interface {
    Upload()
}

type ImageUploader struct {
    Url string
}

func (u *ImageUploader) Upload() {
    fmt.Println(fmt.Sprintf("正在上传图片到 %s", u.Url))
}

type ImageUploaderProxy struct {
    uploader ImageUploader
}

func (u *ImageUploaderProxy) Upload() {
    fmt.Println(fmt.Sprintf("准备上传图片到 %s", u.uploader.Url))
    u.uploader.Upload()
    fmt.Println(fmt.Sprintf("上传图片到 %s 完成", u.uploader.Url))
}

func NewImageUploaderProxy(uploader ImageUploader) *ImageUploaderProxy {
    return &ImageUploaderProxy{uploader: uploader}
}
```

### 桥接模式

理解：一个类存在两个或者多个独立变化的维度，我们可以通过组合的方式，让这两个（或多个）维度可以独立的进行扩展。

```go
type CoffeeCupType uint8
type CoffeeAdditionType uint8

const (
    CoffeeCupTypeSmall  CoffeeCupType = iota // 小杯
    CoffeeCupTypeMedium                      // 中杯
    CoffeeCupTypeLarge                       // 大杯
)

const (
    CoffeeAdditionTypeNoIce CoffeeAdditionType = iota // 去冰
    CoffeeAdditionTypeSugar                           // 加糖
    CoffeeAdditionTypeMilk                            // 加奶
)

type Coffee interface {
    MakeCoffee()
}

type CoffeeAddition interface {
    AddAddition()
}

type SmallCoffee struct {
    CoffeeAddition
}

func (c SmallCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲小杯咖啡")
}

type MediumCoffee struct {
    CoffeeAddition
}

func (c MediumCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲中杯咖啡")
}

type LargeCoffee struct {
    CoffeeAddition
}

type NoIce struct {
}

func (a NoIce) AddAddition() {
    fmt.Println("咖啡去冰")
}

type Milk struct {
}

func (m Milk) AddAddition() {
    fmt.Println("咖啡加奶")
}

type Sugar struct {
}

func (m Sugar) AddAddition() {
    fmt.Println("咖啡加糖")
}

func (c LargeCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲大杯咖啡")
}

var coffeeAdditionFuncMap = map[CoffeeAdditionType]func() CoffeeAddition{
    CoffeeAdditionTypeNoIce: NewNoIce,
    CoffeeAdditionTypeMilk:  NewMilk,
    CoffeeAdditionTypeSugar: NewSugar,
}

func NewCoffeeAddition(additionType CoffeeAdditionType) CoffeeAddition {
    h, ok := coffeeAdditionFuncMap[additionType]
    if ok {
        return h()
    }

    return nil
}

func NewNoIce() CoffeeAddition {
    return &NoIce{}
}

func NewMilk() CoffeeAddition {
    return &Milk{}
}

func NewSugar() CoffeeAddition {
    return &Sugar{}
}

func NewSmallCoffee(additionType CoffeeAdditionType) Coffee {
    return &SmallCoffee{NewCoffeeAddition(additionType)}
}

func NewMediumCoffee(additionType CoffeeAdditionType) Coffee {
    return &MediumCoffee{NewCoffeeAddition(additionType)}
}

func NewLargeCoffee(additionType CoffeeAdditionType) Coffee {
    return &LargeCoffee{NewCoffeeAddition(additionType)}
}

var coffeeFuncMap = map[CoffeeCupType]func(CoffeeAdditionType) Coffee{
    CoffeeCupTypeSmall:  NewSmallCoffee,
    CoffeeCupTypeMedium: NewMediumCoffee,
    CoffeeCupTypeLarge:  NewLargeCoffee,
}

func NewCoffee(cupType CoffeeCupType, additionType CoffeeAdditionType) Coffee {
    h, ok := coffeeFuncMap[cupType]
    if ok {
        return h(additionType)
    }

    return nil
}
```

### 装饰者模式

通过嵌套实现多个功能的扩展。

与代理模式的差别：代理模式附加的功能是和原始类不相关的功能

```go
// MusicPlayer 音乐播放器
type MusicPlayer interface {
	PlayMusic()
}

type Mp3Player struct {
}

func (p Mp3Player) PlayMusic() {
	fmt.Println("播放器播放音乐")
}

// LyricMusicPlayer 携带展示歌词的音乐播放器
type LyricMusicPlayer interface {
	MusicPlayer
	ShowLyric()
}

type Mp4Player struct {
	MusicPlayer
}

func (p Mp4Player) ShowLyric() {
	fmt.Println("播放器展示歌词")
}
```

### 适配器模式

为了兼容解决一些原始类或者接口设计上的缺陷，或者为了将外部类或者接口做一些整合。

```go
type Player interface {
	ShowLyric()
	PlayMusic(isStop bool, prev bool, next bool, addVolume int)
	TurnOff()
}

type NormalPlayer struct {
}

func (n NormalPlayer) ShowLyric() {
	fmt.Println("播放器显示歌词")
}

func (n NormalPlayer) PlayMusic(isStop bool, prev bool, next bool, addVolume int) {
	fmt.Println("播放器播放音乐")
}

func (n NormalPlayer) TurnOff() {
	fmt.Println("关闭播放器")
}

type PlayerOpts struct {
	IsStop    bool
	Prev      bool
	Next      bool
	AddVolume int
}

type PlayerAdapter interface {
	ShowLyric()
	PlayMusic(*PlayerOpts)
	TurnOff()
}

type SmartPlayer struct {
	Player
}

func (s SmartPlayer) PlayMusic(opts *PlayerOpts) {
	fmt.Println("智能播放器播放音乐")
}
```

### 门面模式（外观模式）

为子系统提供一组统一的接口，定义一组高层接口让子系统更容易用。

```go
type ProductOrder interface {
	PlaceOrder()
}

type OrderNotify interface {
	SendUserMsg()
}

type Inventory interface {
	ChangeInventory()
}

type BookOrder struct {
}

func (o *BookOrder) PlaceOrder() {
	fmt.Println("书籍下单")
}

type BookOrderNotify struct {
}

func (o *BookOrderNotify) SendUserMsg() {
	fmt.Println("书籍下单通知")
}

type BookInventory struct {
}

func (o *BookInventory) ChangeInventory() {
	fmt.Println("书籍库存扣减")
}

type ShoppingCar struct {
	ProductOrder
	OrderNotify
	Inventory
}

func (c *ShoppingCar) Buy() {
	c.PlaceOrder()
	c.ChangeInventory()
	c.SendUserMsg()
}
```

### 组合模式

主要用于处理树形结构数据。

```go
type FileNodeSystem interface {
    GetPath() string
    CountFilesNum() int
}

type File struct {
    path string
}

func (f *File) CountFilesNum() int {
    return 1
}

func (f *File) GetPath() string {
    return f.path
}

func NewFile(path string) *File {
    return &File{path: path}
}

type Directory struct {
    path     string
    subNodes []FileNodeSystem
}

func NewDirectory(path string) *Directory {
    return &Directory{
        path: path,
    }
}

func (node *Directory) CountFilesNum() int {
    fileNums := 0
    for _, subNode := range node.subNodes {
        fileNums += subNode.CountFilesNum()
    }

    return fileNums
}

func (node *Directory) GetPath() string {
    return node.path
}

func (node *Directory) AddSubNode(subNode ...FileNodeSystem) {
    if len(subNode) == 0 {
        return
    }

    node.subNodes = append(node.subNodes, subNode...)
}

func (node *Directory) RemoveSubNode(subNode FileNodeSystem) {
    nodeSize := len(node.subNodes)
    i := 0
    for ; i < nodeSize; i++ {
        currPath := strings.ToLower(node.subNodes[i].GetPath())
        subNodePath := strings.ToLower(subNode.GetPath())
        if currPath == subNodePath {
            break
        }
    }

    if i >= nodeSize {
        return
    }

    newSubNodes := node.subNodes[0:i]
    newSubNodes = append(newSubNodes, node.subNodes[i+1:]...)
    node.subNodes = newSubNodes
}

func Demo(t *testing.T) {
	root := NewDirectory("/")
	dir1 := NewDirectory("/a")
	dir2 := NewDirectory("/b")
	root.AddSubNode(dir1, dir2)

	file1 := NewFile("/a/demo1.md")
	file2 := NewFile("/a/demo2.md")
	dir1SubDir := NewDirectory("/a/aSub1")
	dir1.AddSubNode(file1, file2, dir1SubDir)

	fmt.Println(root.CountFilesNum())
}
```

### 享元模式

享元：被共享的单元，目的是复用对象，节省内存。作为享元的对象是不可变对象。

不可变对象：对象初始化后，其属性均不能被修改。

```go
type Color int

var Red Color = 0
var Black Color = 1

type ChessPieceUint struct {
	id    int
	text  string
	color Color
}

func NewChessPieceUnit(id int, text string, c Color) *ChessPieceUint {
	return &ChessPieceUint{
		id:    id,
		text:  text,
		color: c,
	}
}

var chessPieceUints = map[int]*ChessPieceUint{}

func init() {
	chessPieceUints[1] = NewChessPieceUnit(1, "车", Red)
	chessPieceUints[2] = NewChessPieceUnit(2, "马", Red)
	// ... 以此类推
}

type ChessPiece struct {
	*ChessPieceUint
	PosX int
	PoxY int
}

func NewChessPiece(unit *ChessPieceUint, poxX, poxY int) *ChessPiece {
	return &ChessPiece{
		ChessPieceUint: unit,
		PosX:           poxX,
		PoxY:           poxY,
	}
}

type ChessBoard struct {
	chessPieces map[int]*ChessPiece
}

func NewChessBoard() *ChessBoard {
	b := ChessBoard{}
	chessPieces := map[int]*ChessPiece{}
	chessPieces[1] = NewChessPiece(chessPieceUints[1], 0, 0)
	chessPieces[1] = NewChessPiece(chessPieceUints[2], 1, 0)
	// ... 以此类推

	b.chessPieces = chessPieces
	return &b
}
```



