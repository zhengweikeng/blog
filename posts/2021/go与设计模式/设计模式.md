# 设计模式

[toc]

## 创建型

### 单例模式

定义：一个类只允许创建一个对象（或者实例），这个类就是单例类，该设计模式叫单例设计模式，简称单例模式。

#### 饿汉模式

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log = newLogger("default logger")

func getLogger() *logger {
    return log
}
```

#### 懒汉模式

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var m sync.Mutex

func GetLogger() *logger {
    m.Lock()
    if log == nil {
        log = newLogger("default logger")
    }
    m.Unlock()

    return log
}
```

#### 饿汉与懒汉兼容

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var m sync.Mutex

func GetLogger() *logger {
    if log == nil {
        m.Lock()
        if log == nil {
            log = newLogger("hungry&lazy logger")
        }
        m.Unlock()
    }

    return log
}
```

#### 优雅实现

```go
type logger struct {
    Name string
}

func newLogger(name string) *logger {
    // ... 初始化logger
    return &logger{name}
}

var log *logger
var once sync.Once

func GetLogger() *logger {
    once.Do(func() {
        log = newLogger("singleton logger")
    })

    return log
}
```

### 工厂模式

#### 简单工厂

```go
type Human interface {
    Speak()
}

type HumanType uint

const (
    HumanTypeChinese HumanType = iota
    HumanTypeJapanese
    HumanTypeAmerican
)

type Chinese struct {
}

func (c Chinese) Speak() {
    fmt.Println("I speak Chinese")
}

type Japanese struct {
}

func (j Japanese) Speak() {
    fmt.Println("I speak Japanese")
}

type American struct {
}

func (a American) Speak() {
    fmt.Println("I speak American English")
}

type HumanFactory struct {
}

func (f HumanFactory) ProduceHuman(humanType HumanType) Human {
    if humanType == HumanTypeChinese {
        return &Chinese{}
    } else if humanType == HumanTypeJapanese {
        return &Japanese{}
    } else if humanType == HumanTypeAmerican {
        return &American{}
    } else {
        return nil
    }
}
```

#### 工厂方法

```go
type Human interface {
    Speak()
}

type HumanType uint
type HumanFactory func() Human

const (
    HumanTypeChinese HumanType = iota
    HumanTypeJapanese
    HumanTypeAmerican
)

type Chinese struct {
}

func (c Chinese) Speak() {
    fmt.Println("I speak Chinese")
}

func produceChinese() Human {
    return &Chinese{}
}

type Japanese struct {
}

func (j Japanese) Speak() {
    fmt.Println("I speak Japanese")
}

func produceJapanese() Human {
    return &Japanese{}
}

type American struct {
}

func (a American) Speak() {
    fmt.Println("I speak American English")
}

func produceAmerican() Human {
    return &American{}
}

var humanFactoryGenMap = map[HumanType]HumanFactory{
    HumanTypeChinese:  produceChinese,
    HumanTypeJapanese: produceJapanese,
    HumanTypeAmerican: produceAmerican,
}

func GetHumanFactory(humanType HumanType) HumanFactory {
    if h, ok := humanFactoryGenMap[humanType]; ok {
        return h
    }

    return nil
}

func HumanSpeak(humanType HumanType) {
    humanFactory := GetHumanFactory(humanType)
    if humanFactory == nil {
        return
    }

    human := humanFactory()
    human.Speak()
}
```

#### 抽象工厂

```go
type Human interface {
	Speak()
}

type HumanCreateFactory interface {
	ProduceHuman()
}

type ChineseFactory struct {
}

func (f ChineseFactory) ProduceHuman() Human {
	return &Chinese{}
}

type Chinese struct {
}

func (c Chinese) Speak() {
	fmt.Println("I speak Chinese")
}

type JapaneseFactory struct {
}

func (f JapaneseFactory) ProduceHuman() Human {
	return &Japanese{}
}

type Japanese struct {
}

func (j Japanese) Speak() {
	fmt.Println("I speak Japanese")
}

type AmericanFactory struct {
}

func (f AmericanFactory) ProduceHuman() Human {
	return &American{}
}

type American struct {
}

func (a American) Speak() {
	fmt.Println("I speak American English")
}
```

### 建造者模式

使用场景：当实例化对象的时候参数比较多，且参数之间存在依赖时可以考虑使用建造者模式。

```go
const (
    defaultMaxTotal = 10
    defaultMaxIdle  = 5
)

type ResourcePoolConfig struct {
    name     string
    maxTotal uint
    maxIdle  uint
    minIdle  uint
}

func newResourcePoolConfig(build *resourcePoolBuilder) *ResourcePoolConfig {
    return &ResourcePoolConfig{
        name:     build.name,
        maxTotal: build.maxTotal,
        maxIdle:  build.maxIdle,
        minIdle:  build.minIdle,
    }
}

type resourcePoolBuilder struct {
    name     string // 必填
    maxTotal uint   // 必填
    maxIdle  uint   // 必填
    minIdle  uint   // 选填
}

func NewResourcePoolBuilder() *resourcePoolBuilder {
    return &resourcePoolBuilder{
        maxTotal: defaultMaxTotal,
        maxIdle:  defaultMaxIdle,
    }
}

func (builder *resourcePoolBuilder) Build() (*ResourcePoolConfig, error) {
    if builder.name == "" {
        return nil, errors.New("name不能为空")
    }

    if builder.maxTotal == 0 {
        return nil, errors.New("maxTotal不能0")
    }

    if builder.maxIdle == 0 {
        return nil, errors.New("maxIdle不能0")
    }

    if builder.minIdle > builder.maxIdle {
        return nil, errors.New("minIdle不能大于maxIdle")
    }

    return newResourcePoolConfig(builder), nil
}

func (builder *resourcePoolBuilder) SetName(name string) *resourcePoolBuilder {
    builder.name = name
    return builder
}

func (builder *resourcePoolBuilder) SetMaxTotal(maxTotal uint) *resourcePoolBuilder {
    builder.maxTotal = maxTotal
    return builder
}

func (builder *resourcePoolBuilder) SetMaxIdle(maxIdle uint) *resourcePoolBuilder {
    builder.maxIdle = maxIdle
    return builder
}

func (builder *resourcePoolBuilder) SetMinIdle(minIdle uint) *resourcePoolBuilder {
    builder.minIdle = minIdle
    return builder
}
```

使用示例：

```go
func GetMysqlResourceConfig() (*ResourcePoolConfig,error) {
    resourceConfig, err := NewResourcePoolBuilder().
        SetName("mysql_pool_config").
        SetMaxTotal(50).
        SetMaxIdle(10).
        SetMinIdle(5).
        Build()
    if err != nil {
        return nil, err
    }
    
    return resourceConfig, nil
}
```

## 结构型

### 代理模式

```go
type Uploader interface {
    Upload()
}

type ImageUploader struct {
    Url string
}

func (u *ImageUploader) Upload() {
    fmt.Println(fmt.Sprintf("正在上传图片到 %s", u.Url))
}

type ImageUploaderProxy struct {
    uploader ImageUploader
}

func (u *ImageUploaderProxy) Upload() {
    fmt.Println(fmt.Sprintf("准备上传图片到 %s", u.uploader.Url))
    u.uploader.Upload()
    fmt.Println(fmt.Sprintf("上传图片到 %s 完成", u.uploader.Url))
}

func NewImageUploaderProxy(uploader ImageUploader) *ImageUploaderProxy {
    return &ImageUploaderProxy{uploader: uploader}
}
```

### 桥接模式

理解：一个类存在两个或者多个独立变化的维度，我们可以通过组合的方式，让这两个（或多个）维度可以独立的进行扩展。

```go
type CoffeeCupType uint8
type CoffeeAdditionType uint8

const (
    CoffeeCupTypeSmall  CoffeeCupType = iota // 小杯
    CoffeeCupTypeMedium                      // 中杯
    CoffeeCupTypeLarge                       // 大杯
)

const (
    CoffeeAdditionTypeNoIce CoffeeAdditionType = iota // 去冰
    CoffeeAdditionTypeSugar                           // 加糖
    CoffeeAdditionTypeMilk                            // 加奶
)

type Coffee interface {
    MakeCoffee()
}

type CoffeeAddition interface {
    AddAddition()
}

type SmallCoffee struct {
    CoffeeAddition
}

func (c SmallCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲小杯咖啡")
}

type MediumCoffee struct {
    CoffeeAddition
}

func (c MediumCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲中杯咖啡")
}

type LargeCoffee struct {
    CoffeeAddition
}

type NoIce struct {
}

func (a NoIce) AddAddition() {
    fmt.Println("咖啡去冰")
}

type Milk struct {
}

func (m Milk) AddAddition() {
    fmt.Println("咖啡加奶")
}

type Sugar struct {
}

func (m Sugar) AddAddition() {
    fmt.Println("咖啡加糖")
}

func (c LargeCoffee) MakeCoffee() {
    c.AddAddition()
    fmt.Println("冲大杯咖啡")
}

var coffeeAdditionFuncMap = map[CoffeeAdditionType]func() CoffeeAddition{
    CoffeeAdditionTypeNoIce: NewNoIce,
    CoffeeAdditionTypeMilk:  NewMilk,
    CoffeeAdditionTypeSugar: NewSugar,
}

func NewCoffeeAddition(additionType CoffeeAdditionType) CoffeeAddition {
    h, ok := coffeeAdditionFuncMap[additionType]
    if ok {
        return h()
    }

    return nil
}

func NewNoIce() CoffeeAddition {
    return &NoIce{}
}

func NewMilk() CoffeeAddition {
    return &Milk{}
}

func NewSugar() CoffeeAddition {
    return &Sugar{}
}

func NewSmallCoffee(additionType CoffeeAdditionType) Coffee {
    return &SmallCoffee{NewCoffeeAddition(additionType)}
}

func NewMediumCoffee(additionType CoffeeAdditionType) Coffee {
    return &MediumCoffee{NewCoffeeAddition(additionType)}
}

func NewLargeCoffee(additionType CoffeeAdditionType) Coffee {
    return &LargeCoffee{NewCoffeeAddition(additionType)}
}

var coffeeFuncMap = map[CoffeeCupType]func(CoffeeAdditionType) Coffee{
    CoffeeCupTypeSmall:  NewSmallCoffee,
    CoffeeCupTypeMedium: NewMediumCoffee,
    CoffeeCupTypeLarge:  NewLargeCoffee,
}

func NewCoffee(cupType CoffeeCupType, additionType CoffeeAdditionType) Coffee {
    h, ok := coffeeFuncMap[cupType]
    if ok {
        return h(additionType)
    }

    return nil
}
```

### 装饰者模式

通过嵌套实现多个功能的扩展。

与代理模式的差别：代理模式附加的功能是和原始类不相关的功能

```go
// MusicPlayer 音乐播放器
type MusicPlayer interface {
	PlayMusic()
}

type Mp3Player struct {
}

func (p Mp3Player) PlayMusic() {
	fmt.Println("播放器播放音乐")
}

// LyricMusicPlayer 携带展示歌词的音乐播放器
type LyricMusicPlayer interface {
	MusicPlayer
	ShowLyric()
}

type Mp4Player struct {
	MusicPlayer
}

func (p Mp4Player) ShowLyric() {
	fmt.Println("播放器展示歌词")
}
```

### 适配器模式

为了兼容解决一些原始类或者接口设计上的缺陷，或者为了将外部类或者接口做一些整合。

```go
type Player interface {
	ShowLyric()
	PlayMusic(isStop bool, prev bool, next bool, addVolume int)
	TurnOff()
}

type NormalPlayer struct {
}

func (n NormalPlayer) ShowLyric() {
	fmt.Println("播放器显示歌词")
}

func (n NormalPlayer) PlayMusic(isStop bool, prev bool, next bool, addVolume int) {
	fmt.Println("播放器播放音乐")
}

func (n NormalPlayer) TurnOff() {
	fmt.Println("关闭播放器")
}

type PlayerOpts struct {
	IsStop    bool
	Prev      bool
	Next      bool
	AddVolume int
}

type PlayerAdapter interface {
	ShowLyric()
	PlayMusic(*PlayerOpts)
	TurnOff()
}

type SmartPlayer struct {
	Player
}

func (s SmartPlayer) PlayMusic(opts *PlayerOpts) {
	fmt.Println("智能播放器播放音乐")
}
```



