> 最近开始读《现代操作系统》，记录下自己的一些理解

# 进程
在进程模型中，计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程（sequential process），简称进程（process）。可以简单的认为，一个进程就是一个正在运行程序的实例。

这就可以理解了，进程是活的，是跑动着的程序。

```
就例如你要开始下厨。食谱中的每一道工序就是程序，描述着所有步骤和处理方式。而当你开始行动，无论是洗菜，切菜，炒菜等操作都是一个个进程。
```

但是进程是伪并行的，只是进程间的快速切换，我们没法察觉到。这说明了，任何一个时候都只有一个进程在运行。当然这个假设是建立在单个CPU的基础上的，现今的计算机都是多核计算机，拥有多个CPU，这也使得多个进程可以分布在多个CPU中同时运行。

进程间也是相互独立的，每个进程都有自己独立的地址空间，每个进程间的数据是无法共享的。

```
例如当你在下厨下到一半的过程，有客人来了，你需要去待客。你没法同时下厨和接待客人。此时你会暂停下厨，记录下目前下厨的状态，做到哪个工序，等下回来从这个状态恢复继续。

这两件事是相互独立的。

但是当你的家中有多一个人的时候，就相当于多一个CPU了，他便可以去待客，你继续下厨。
```

## 进程的基本概念
### 进程的创建
一般来说，系统启动的时候，会先创建一些进程。而进程还可以去创建其他进程。  
而这些进程有前台进程，也有后台进程。前台进程就是和用户交互的进程，如打开一个音乐软件。而后台进程就是启动后，默默在后台运行的进程，我们也称之为守护进程（daemon）。
```
使用iphone的最能体会了，当你对锁屏着的手机说：“嘿，siri”，这时siri就会被唤醒，这说明此时siri是作为守护进程存在的。
```

而UNIX和windows创建进程的方式却不同。

* UNIX机器，同个调用fork()函数后，就创建了一个进程，这个进程称之为子进程。
  1. 该进程与父进程有相同的副本，也就是继承了一些父进程的数据
  1. 父进程可以创建多个子进程，子进程只拥有一个父进程
  1. 整个进程结构就像一个树一样，从根节点一直散发
* WINDOWS机器，会通过win32调用CreateProcess函数，并传入一些参数
  1. 没有像树一样的层次结构，每个进程的地位都是相同的。
  1. 父进程创建子进程会得到一个令牌（称之为句柄），用来控制子进程。但是父进程可以把句柄传递给其他子进程，这样兄弟进程便可以互相控制了，没有所谓的树结构意义了。

### 进程的终止
进程终止有几种情况
1. 正常退出
1. 出错退出
1. 严重错误
1. 被其他进程杀死（非自愿）

这些都很好理解

### 进程的状态
虽然进程间是独立的，但是很多情况下，进程间是相互协作的。

例如 `cat text | grep hello`

cat进程在获取完数据后，调用grep进程，筛选出hello。

这里涉及到两个进程相互协作的问题，后一个进程必须等待前一个进程结束后才可以运行，在前一个进程没有完成之前，后一个进程会处于等待的状态。

进程状态分为3种：

1. 运行态（该时刻进程实际占用CPU）
1. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
1. 阻塞态（除非某种外部事件发生，否则进程不能运行）

进程状态的相互转化：

1. 从运行态--->阻塞态，进程为等待输入而阻塞。例如上述例子中的gerp在等待cat的完成
1. 从运行态--->就绪态，调度程序选择另外一个进程。例如上述例子，在调用cat读取文件时，文件太大，读取时间（也即占用CPU的时间）过长，调度程序会将CPU让给其他进程调用
1. 从就绪态--->运行态，调度程序选择了这个进程。例如上述例子，cat恢复调用
1. 从阻塞态--->就绪态，出现了有效输入，需要注意的是，阻塞是不能直接进入运行态的，得重新排队，等到CPU空闲了并且轮到它运行才能运行

# 线程
在传统的操作系统，进程拥有独立的内存地址空间和一个用于控制的线程。但是，如今这种设计是无法满足现状的，更多的是要求，在同一个地址空间下拥有多个线程并发执行。

网上看到这么一个案例觉得挺恰当。

```
有一款写作软件，它会监听我们打字时的输入状态，每个5分钟对草稿进行自动保存。

想象只有单进程单线程的场景，在我保存的时候，需要访问硬盘，而访问硬盘的线程是阻塞的，这时我的任何输入都是没有响应的，真的是很糟糕的体验，我们只能通过键盘或者鼠标的输入去中断保存的过程。

但是当我们拥有多线程后，每个线程就都可以去处理自己的事情了，保存线程处理保存，输入线程处理输入，而这都是在一个进程下完成的。
```

从上述例子，我们可以明确看到多线程的好处。有一点必须明确，线程是在进程下的，多个线程之间是共享进程的内存地址空间的

再来看看线程的好处
1. 在很多程序中，需要多个线程互相同步或互斥的并行完成工作，而这时进程无法做到的。
1. 线程相比进程来说，更加的轻量，而且线程的创建和销毁的代价都比进程小很多。
1. 使用线程会提高性能，上述案例就是一个例子。宏观上的线程虽然是并行的，但是追究到微观上，实际上它还是串行的。从CPU角度线程并无法提升性能，但如果某些线程涉及到等待资源（比如IO，等待输入）时，多线程允许进程中的其它线程继续执行而不是整个进程被阻塞，因此提高了CPU的利用率，从这个角度会提升性能。
1. 当你使用多核计算机时，线程也即真正的并行了。

同进程一样，线程也拥有三种状态。运行态、就绪态、阻塞态。

# 进程间通信（IPC）
大多数情况下，进程间是需要相互协作的，需要相互传递数据，因此也有了进程间如何通信的问题。

总的来说，进程间通信需要解决如下问题
1. 一个进程如何把信息传递给另外一个
1. 确保两个进程或者多个进程间在临界活动时不会彼此影响
1. 当存在依赖关系时确定次序

上面三个问题对于线程间通信也是一样的，所以解决了进程间通信也即解决了线程间的通信。  
其中第一个问题线程解决起来很简单，因为多个线程是共享同一个地址空间的。

## 竞争条件
两个或多个进程读写某些共享数据，而最后结果取决于进程运行的精确时序，就称为竞争条件。

假想一个例子
```
有2个写文件的进程同时运行，通过追加的方式，往一个文件中追加内容。

假设文件目前是如下内容
1. abc
2. def
3. ghi

文件中有3行，新的内容将从第四行开始写入。
此时A和B进程都要来写入了，A和B都读取到从第四行开始写入，此时A先写，此时调度程序认为A已经占用足够时间了，切换到B进程写入，也从第四行开始写入。
于是便把A写入的东西覆盖掉了。

A和B就是相互竞争的关系
```

## 临界区
要避免竞争条件，其实就是要避免进程间访问共同的内存区域，让进程访问的时候造成互斥现象

我们把对共享内存进行访问的程序片段称为临界区(critical region) 。如果能够进行适当安排，使得进程不可能同时处于临界区，则能够避免竞争条件。

一个好的解决方案需要拥有如下四个条件：
1. 任何两个进程不能同时处于临界区
1. 不应对CPU的速度和数目做任何假设
1. 临界区外的进程不得阻塞其他进程
1. 不得使进程无限期等待进入临界区

```
A进入临界区       A离开临界区
|               |
|               |
================--------------
T1              T2
----------------=======================---------
                |                      |
                |                      |
                B进入临界区              B离开临界区

当A在T1时刻进入临界区时，如果此时B也想进入，此时B失败了，只能等待A离开临界区
当A离开临界区后，B便能进入临界区了，从而保证了临界区只有一个进程访问。
```

## 实现互斥的方案
### 屏蔽中断
每个进程在进入临界区后，立即屏蔽所有中断，并在离开之前再打开中断，屏蔽中断后，时钟中断也会被屏蔽，这时会是的CPU无法被切换，可以避免其他进程进入。

这种方式其实很不好，如果离开的时候万一没有打开中断，整个系统不就停止了。

而且这种方式还是针对单核机器的，多核机器下，其他CPU依旧是可以切换进程的，在其他CPU的进程还是可以进入临界区。

### 锁变量
设想一个共享（锁）变量，初值为0，当一个进程想进入其临界区时，它首先测试这把锁，如果锁的值为0，则进程将其置为1并进入临界区。若锁已经为1，则进程将一直等待到值变成0。

其实依旧没法解决。试想当A进程读取到该变量值为0时，当它在想修改锁变量的时候，B也读取到该变量还是0，于是也进入了临界区，也要修改锁变量值为1。此时两个变量已经都进入了临界区。

还有其他方案，如严格轮换法，Peterson解法等等，但是都有一些问题，无法很好的解决问题，主要思想都是让一个进程在全局变量中操作数据时，其他的进程就不能进入，直到该进程数据操作结束，其他进程才可以进入

目前常见的进程间通信有管道、信号、消息队列、共享内存

## 常见的进程间通信方案
### 无名管道（pipe）
1. 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道
1. 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
1. 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
1. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

*只要两个进程中存在亲缘关系,这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信*

### 有名管道（FIFO）
无名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。

FIFO提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。值的注意的是，FIFO严格遵循先进先出(first in first out),对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。

### 信号
信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。

信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了那些系统事件。

*nix系统提供了一个叫`kill`的命令，它可以进行不同进程信号的传递

![process1](../images/process1.png)
可以看到，它`kill -l`列出了所有信号的名字

我们可以根据这些名字去给进程发送信号，例如给pid为507的进程发送挂起的信号
```bash
$ kill -s HUP 507
```

如果没有指定信号名字，则默认值为`TERM`，即一下效果是一样的
```bash
$ kill -s TERM 507
$ kill 507
```

也可以直接接信号的数字值，例如我们想给程序发送`ctrl+c`的信号，假设我们在终端输入`node`，进入Node.js的交互命令行状态，此时我们可以按ctrl+c进行退出，也可以使用信号退出
```bash
$ kill -2 99040
```

### 消息队列
消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

### 共享内存
顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

特别提醒：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如前面说到的信号量

#### socket
在机器上监听一个端口，便可以进行不同机器间的通信。采用sokcet的方式，基于tcp或者udp来进行进程间的通信，这是非常常用的方式。
