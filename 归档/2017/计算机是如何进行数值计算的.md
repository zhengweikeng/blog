# 整数的加法和减法
计算机无论是加法还是减法，都是采用补码进行计算加减

看个事例，我们前提机器是4位机器（方便演示而已）
```
8 + 4
计算机会用8的补码和4的补码进行运算，而正数的补码和原码是一样的，所以才和正常的原码计算一样
1000 + 0100 = 1100
1010转化为十进制即为12，和预期结果一致

8 - 4
这时会转化成加法运算
8 + (-4)
此时计算机会用8的补码和-4的补码进行运算。
1000 + 1100 = 10100
此时最高位溢出，直接舍弃，所以结果为0100，转化为十进制为4，和预期结果一致
```

*那问题就来了，为什么一定要转化补码这么麻烦来计算呢，一开始我也是懵逼，直到看了这篇 [文章](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)*

# 整数的乘法和除法
计算机计算乘法和除法感觉会更加简单，直接采用了左移和右移的原理

## 先看看左移和右移的原理
左移一位代表乘以2，n位代表乘以2^n
```
计算5的二进制左移2位

5 ===>  101

101 << 2 
===>
10100

转化为十进制即为20，也即5*2^2
```

右移一位代表除以2，n代表除以2^n
```
计算20的二进制右移2位

20 ===> 10100

10100 >> 2
===>
00101

转化为十进制即为5，也即20 / 2^2
```

由此可见，计算机底层如果计算这种与2的乘除运算，采用左移和右移是最简单和最省力的方式

## 乘法运算
对于a乘以x而言，只是将a左移x为1的位并累加即可。

计算14*5
```
14 ===> 1110
5 ===> 101

1110 * 101

第一步，101的第0位为1，则将1110左移0位，即还是1110（所以第一位都是不用理会的）

第二步，101的第一位为0，直接忽略

第三步，101的第二位为1，则将1110左移2位，即111000

将所有结果相加 111000 + 1110 = 1000110
转化为十进制为70，和预期结果一致
```

## 除法运算
除法运算和我们一般的除法法则是一致的，只是十进制的时候我们采取的是每一项都从0-9选取，现在则是从0-1选取
```
28 / 5
===> 
11100 / 101

第一次 1余10
第二次 0余100
第三次 1余11

所以结果为101余11
也即5余3
```

# 浮点数
浮点数实在很复杂，先放个 [链接](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)