为了避免redis宕机或者宿主机器故障导致redis的短暂不可用，redis提供了主从复制的功能。  

有几点需要认识：
1. 主服务器可以有多个从服务器
2. 复制功能不会阻塞主服务器，即使是进行初次同步也不会阻塞主服务器
3. 复制功能也不会阻塞从服务器
4. 从节点也可以有自己的从节点

实现主从复制的方式：
1. 通过slaveof命令
2. 通过配置的方式

例如在从节点机器通过slaveof方式，称为指定ip和端口的redis的从节点
```bash
redis> slaveof 192.168.33.10 6379
```
在从节点机器取消从节点
```bash
redis> slaveof no one
```

在从节点机器配置文件
```
slaveof ip port
# 从节点值只做读操作
slave-read-only yes
```

需要注意的是，当节点成为从节点时，自身拥有的数据会被全部清空，以主节点为主。

## 主从复制过程
### 全量复制
1. 当从节点连接到主节点时，会先进行全量复制。即主节点会采用bgsave的方式生成rdb文件
2. 在全量复制期间主节点产生的数据，主节点会将这批新数据放入缓冲区
3. 主节点发送rdb文件给从节点，之后再发送缓冲区的数据给从节点
4. 从节点删除旧数据，载入rdb文件和主节点传输过来的缓冲区的数据

在2.8.18开始，redis支持无盘复制，即主节点直接通过socket将rdb快照内容发送到从节点，不用产生本地的rdb文件，提高了效率。从节点没有变化，依旧需要接收rdb内容，生成rdb文件到磁盘中，再进行一次性加载。

### 增量同步
在做完全量复制之后，如果由于网络原因，主从节点间的网络断开了，当连接恢复后，如果还是做全量复制的话就很不值得了，全量复制在数据量很大时很耗性能和网络带宽。

这时候只需要做部分复制即可。

redis在底层提供了数据偏移量，主从节点都会维护一个偏移量，用于记录当前复制的状态。通过该偏移量主节点能够知道该从节点复制到哪份数据，这样只需传输最新的数据给从节点即可。

但如果从节点的偏移量和主节点差别太大超过某个限制值，主节点会采用全量复制的方式进行同步。

主节点会将修改指令记录在自己的内存buffer中，然后异步的将buffer中的指令数据同步到从节点，从节点需要接收主节点的同步指令将数据达成一致状态，同时它还需要告诉主节点目前自己同步到哪里来，这是通过偏移量来进行的。

这里我们提到了内存buffer，那么就会有个问题，内存buffer的空间是有限的，如果这个空间满了，redsi会从头开始覆盖前面的内容。  
如果这个时候网络不好了，导致从节点同步的速度非常慢，或者甚至无法同步，那么数据就丢失了。  

此时redis便会采用全量复制，将rdb文件传过去，这是个非常重的操作，而且它需要清空从库的所有数据。  
而此时内存buffer还在不断向前移动，如果全量复制时间过长，或者buffer太小，都会导致内存数据被从头开始覆盖，然后redis又开始进行全量复制，成为一个死循环。

因此必须配置一个合适大小的buffer，避免全量复制时产生死循环。