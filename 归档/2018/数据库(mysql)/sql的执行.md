# mysql日志系统
mysql有完善的数据备份和恢复机制，能够帮助我们在系统出问题或者误操作后及时的进行恢复，这里面采用的就是mysql的日志系统。

mysql包含两种日志：
1. redo log，重做日志
2. bin log，归档日志

当我们在做数据插入、删除和修改的时候，会产生上面两种日志，记录我们所做的操作，而mysql也就是利用这两种日志进行数据恢复的。

假设我们有如下sql：
```sql
UPDATE user SET age=age+1 WHERE id=12;
```
通过这条sql来说明两种日志的差别

## redo log
首先需要知道的是redo日志只有InnoDb引擎的数据库才会有。

正常情况下，当我们采用事务，开始执行上面的语句，首先需要去磁盘查找id=12的那条记录，然后做一次age的更新，然后再将记录写进磁盘，提交事务。

如果每一次的写操作都要做这样的过程的话，整个过程IO成本、查找成本都会很高，因此mysql采用没有选择这么做，而是采用了一种叫WAL，即Write-Ahead Logging。

简单来说，就是当有一条记录需要更新的时候，InnoDb引擎就会先把记录写到redo log里，并更新内存，这时操作就算完成了。而InnoDb引擎会在适当的时候将这个操作记录更新到磁盘里面，一般都会是在引擎比较空闲的时候来做。

另外，redo log文件是固定大小的，数据库会从文件头开始写，写到末尾又回到头开始循环写。

如果我们在提交事务之后，数据尚未刷回磁盘时断电了，这时我们只需要重启数据库，然后数据库会去读取redo log文件，将那些尚未写回磁盘的数据写到磁盘。这个能力，称之为*crash-safe*。

通常，会在数据库的data目录下生成2个以上的文件，文件名格式为`ib_logfile0`、`ib_logfile1`这样，它就是innoDb引擎用来存储redo日志的文件。

可以通过`show variables like 'innodb_log%'`查看相关配置：
```
# redo log文件个数
innodb_log_files_in_group: 2
# ib_logfile文件大小(单位字节)，此处为48MB
innodb_log_file_size: 50331648
# 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下
innodb_log_group_home_dir: ./
```

## undo log
这个日志和redo log很像，不过它记录的是数据被修改前的值，可以用来在事务失败的时候进行rollback。

例如某个事务id为100的事务，想要修改数据x，原始值为1，修改后的值为2，那么undo log会记录(100, x, 1)。而redo log记录的则是(100, x, 2)。

## bin log
上面说过，redo log是InnoDb引擎独有的，那么bin log就是mysql整体的一个日志，任何引擎都可以使用，称为归档日志。

两种日志的差别：
1. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；bin log是逻辑日志，记录的是这个语句的原始逻辑，如上面sql中给id=12的记录age字段+1
2. redo log是循环写，而bin log是追加写，文件写到一定大小后会切换到另一个文件继续写，不会覆盖旧的文件。

同理，可以通过`show variables like 'log_%'`查看相关配置：
```
# on则表示binlog已经开启
log_bin on
log_bin_basename
```

之前的sql的写日志流程
1. 执行器查找id=12的这一行，一般id都是主键，通过索引可以快速找到，如果这一行所在的数据页本来就在内存中，直接返回内存给执行器。否则，需要从磁盘中读取到内存，再返回数据
2. 执行器拿到引擎给的数据，修改数据age = age+1，得到新的一行数据，再调用引擎写入新数据
3. 引擎将这行数据更新到内存，同时将这个操作记录更新到redo log文件中，此时redo log文件处于prepare状态，然后告知执行器执行完成，接下来可以提交事务。
4. 执行器会生成这个操作的bin log，并写入bin log文件。
5. 执行器调用引擎的提交事务接口，引擎把redo log的状态修改为commit状态，更新结束。

我们可以看到，redo log的写入过程分为了2步，即“两阶段提交”，为什么需要这么做呢？

假设先写redo log后写bin log文件，如果redo log写完了，bin log还没写，数据库重启了，此时进行数据恢复，age成功加上了1，完成更新。  
但是bin log里面是没有这条记录的，当我们拿这份备份日志来恢复数据的时候，age就会恢复为更新前的值，数据不一致了。

假设先写bin log后写redo log文件，如果写完bin log写完之后挂了，redo log没写，数据库重启后无法恢复值，age还是更新前的值。但是bin log已经有这条记录，之后用它恢复数据库的时候，age又是+1后的值，数据依旧不一致了。

因此需要通过确认的方式，进行日志的写入和提交。

## 实操
假设某天中午12点，误删了某个表，事后才发现，需要怎么恢复数据？

1. 找到最近一次的全量备份，假设为昨天晚上的备份，恢复到一个临时数据库。
2. 从备份的时间点开始，将备份的binlog逐个取出来，重放到中午12点删表之前的那一刻
3. 此时你已经拥有了被删的表的数据了，而且和被删除前的数据一样，拿着这份数据恢复到线上库即可。