# 表空间释放
随着表数据的不断增加，数据库的空间占用会越来越大，此时我们会想说通过删除部分表中的数据来做一些清理，释放一些空间。

但是有时你会发现，即使你删除了大量的表数据，磁盘空间却依旧没有减少，有时还可能会增加，这是怎么回事呢？

由于我们常用的数据库引擎为innodb，因此一下讨论都是以该引擎为前提。

## 表数据存储
mysql中有个参数
```
innodb_file_per_table=ON
```
当该参数的值是OFF时，表的数据会存储在系统共享表空间，和数据字典存储在一起  
当该参数的值时ON时，每个InnoDB表数据存储在一个以.ibd为后缀的文件中

自mysql5.6.6开始，该参数的默认值就是ON，也建议将该值设置为ON。通过这种方式可以方便的管理表，而且通过drop table的时候，系统只需要直接删除ibd文件即可。   
而如果是放在共享表空间中，即使表被删除了，空间也无法释放。

因此如果你直接删除表后，发现空间没有减小，那么就得看看是不是该参数的问题了。

但其实我们大部分时候并不是在删表，而是删表中的数据，因此我们需要讨论的是，删除表数据后，空间如何释放的问题。

## 数据删除
在innodDB中，数据是按页存储的，例如id为100到500的数据存储在page1中，那么当我们删除id为300的数据的时候，innoDB引擎只是把这条数据在数据页中的记录标记为删除，如果之后还要插入一个id为400的记录时，便可以复用该位置。

正因为如此，你会看到数据页的大小并没有发生变化。

如果删除操作把整个数据页的都删除了，那么整个数据页都是可以复用的。这时如果你要插入的是id为50的记录，本来是需要新开辟一个新页的，但是现在有一个可以复用的页，因此该记录便会添加到该可复用的页上。

另外，如果两个相邻页的利用率都很小，系统就会合并两个页成为一个页。

如果整张表的数据都被删除了，那么所有数据页都被标志位可复用的。这在磁盘上的表现就是，磁盘空间并不会减少。

也就是说`delete`操作并不能释放表空间。

### 反观新增操作
上面说到，delete操作只会给数据页的记录增加一个删除记录，然后可以被后续复用。其实这种操作新增操作也是一样的。

如果你每次插入操作都是按照索引顺序插入的，那么数据页当然就是紧凑的，这没问题。   
但是如果你每次插入都是随机的，例如你这次插入的id为400的记录，下次插入的是id为330的记录，那么数据页就可能会经常做分裂。
```
page1
------------------
|100 -- 200 -- 400|
------------------

# insert data
page1                  page2
------------------    ------------------
|100 -- 200 -- __ |   | 330 -- 400 -- __ |
------------------
```

可以看到，当我们要插入id为330的记录时，需要将page1的部分记录标志为删除，再迁移到page2中，然后再在page2中插入数据。

这就导致了page1中有位置空出，这个位置就是可以被复用的，而且这些位置都是要占用空间的。

这里说的是新增操作，换成更新也是一样的。如果id更新了，其实相当于先删除后插入，一样会造成这种位置空出的情况。

如果出现大量的这种可复用位置的情况，空间占用就会很高，虽然看起来好像没有多少数据。

## 重建表
解决上面数据页空洞的问题，只需要把这些空洞的位置去掉，把索引变得紧凑即可。这种操作称之为”重建表“。

有两种方式可以对表进行重建。假设有一个表A，需要做空间压缩，即重建表。

方式一：
1. 新建一个与表A的表结构一样的表B
2. 按照主键ID递增的顺序，将A的数据逐行复制到表B中。
3. 用表B替换A，删除A

由于表B的索引都是紧凑的，替换后空间将得到释放。

但是这种方式有个问题，就是如果在复制过程中，有新的数据写入表A中，会导致数据丢失。因此有了第二种方式，即Online DDL。

Online DDL是在mysql 5.6版本引入的，流程如下：
1. 新建一个临时文件，扫描表A主键的所有数据页；
2. 用数据页中表A的记录生成B+树，存储到临时文件中；
3. 生成临时文件的过程中，将所有对表A的操作都记录在一个日志文件中(row log)；
4. 临时文件数据添加完成后，将日志中的操作应用到临时文件中，便能得到一个与表A一样的数据文件；
5. 用临时文件替换表A的数据文件

这两种方式自己做的话，都会比较麻烦，因此Mysql提供了如下命令来做到自动化
```sql
alter table A engine=InnoDB;
```
在5.6以前，该语句的执行过程和方式一差不多。到了5.6以后便采用Online DDL了。

另外，我们知道在DDL操作之前是需要拿到MDL写锁的，即当需要对表做alter操作的时候，需要确保拿到了MDL写锁，避免其他线程也在做DDL操作，如果拿到了该锁，其他线程就不能做增删改查操作了。既然如此，何来的Online DDL呢？

其实在拿到MDL写锁后，当进行拷贝数据之前，该锁会退化成MDL读锁，而MDL读锁是不会互斥的，其他线程也可以进行表的增删改查，这样便实现了Online DDL。

这种不会阻塞的DDL，其实是一种原地操作，即它没有挪动数据到临时表，整个过程都在InnoDB内部完成。完整的语句如下
```sql
alter table A engine=InnoDB,ALGORITHM=inplace;
```

而方式一的完整语句如下：
```sql
alter table A engine=InnoDB,ALGORITHM=copy;
```

但是inplace不代表就是online，当你要添加全文索引或者空间索引的时候，虽然是inplace，但是却会阻塞增删改查操作，不是online的。

有几个语句需要区分下
1. analyze table t，该语句是对表的索引信息做重新统计，没有修改数据，只是加了MDL读锁
2. optimize table t，该语句等于alter table t engine + analyze table t

## 思考
有一个表文件大小为1GB，对该表执行`alter table t engine=InnoDB`后，发现空间没有变小，反而变大了，是什么原因？

如果表的数据页本身已经是紧凑的，或者刚做完表重建，又再次执行了表重建，这时就可能导致表空间反而变大。

表重建的时候，InnoDB不会把整张数据页占满，而是每个数据页留1/16给后续的更新用，也就是说，重建后的表，也不是完全紧凑的。

加入你在重建表后，又插入了部分数据，而这部分数据会去填满这部分预留的空间。当你再次重建表后，又会多出1/16的空间，现象就是磁盘空间变大了。