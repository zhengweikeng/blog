# 堆的算法
在算法中，堆是一种数据结构，它是一颗二叉树，如下图所示：  
![person_pb2](../images/堆1.jpeg)

我们常说的堆一般指的是二叉堆，即用二叉树来构建的一种数据结构。  
当一颗二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序  
能够用堆有序的完全二叉树排序的元素就是二叉堆

会采用数组来存放元素，其中，树的每一层都会被填满，除了最后一层，最后一层会从一个节点的左子树开始填。堆采用数组的方式来存储，如`[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]`。给定数组A，其树的根为A[1]，给定某个节点的下标为i，则左儿子和右儿子的下边可以简单的被计算出来:
1. left：i * 2
2. right：(i * 2) + 1
3. parent：i / 2，向下取整

观察上面的计算公式，我们知道在计算机里，可以通过左移和右移来计算与2的乘法和除法，因此也有了如下公式：
1. left：i的二进制左移1位
2. right：i的二进制左移1位并在低位中+1
3. parent：i的二进制右移1位得到i/2

**高度为h的堆中，最多和最少的元素个数？**  
最多元素的情况就是左右子节点全部存在，每一层都会基于上一层的节点个数*2：  
1 + 1 * 2 + 1 * 2 * 2 + ... + 1 * 2^(h) = 1 + 2 + 2^2 + ... + 2^h = 2^(h+1) - 1

最少元素的情况就是最后一层只有一个节点，可以退化成求(h-1)高度的最大元素个数+1，即为2^h

**含N个元素的堆的高度为多少？**  
高度为logN，其中log为以2为底

**高度为h，至多有多少个节点？**  
至多有n/(2^(h+1))，向下取整

二叉堆包含两种：最大堆和最小堆。
1. 最大堆：A[parent(i)] >= A[i]
2. 最小堆：A[parent(i)] <= A[i]

## 堆的操作
一般来说，会使用数组来构造堆，通过数组下标能够直接访问到元素，为了方便表示，数组的第1位（即下标为0）不存放数据。

### 插入元素
当有新的元素要插入堆中时，可以将其插入到堆的末尾，即数组末尾，此时堆的结构可能会被破坏，因此需要重新调整堆，这个过程为堆化。

![insertHeap](../images/e578654f930002a140ebcf72b11eb722.jpg)

这时一般会采用**上浮**的方式进行调整。

当堆中的某个元素发生变化，导致比父元素大时，需要重新调整堆，这时可以采用上浮的方式，逐次判断父节点和变化元素的大小，并且进行交换。

![swim](../images/e3744661e038e4ae570316bc862b2c0e.jpg)

```go
func swim(data []int) {
	i := len(data) - 1
	for i > 1 && data[i/2] < data[i] {
		data[i/2], data[i] = data[i], data[i/2]
		i = i / 2
	}
}

func insert(data []int, value int) []int {
	data = append(data, value)
	swim(data)
	return data
}
```

### 删除堆顶元素
堆的特性告诉我们，每个节点的值都会大于或者小于子节点的值。当我们删除了节点时，也需要重新调整堆结构。

一般来说，删除节点时会采用**下沉**的方式。

![sink](../images/110d6f442e718f86d2a1d16095513260.jpg)

当堆中的某个元素发生变化，导致比子元素小时，需要重新调整堆，这时可以采用下沉的方式，和自己的两个子节点中较大者进行交换
```go
func sink(data []int, n, index int) {
	for {
		maxIndex := index
		if index*2 <= n && data[index] < data[index*2] {
			maxIndex = index * 2
		}
		if index*2+1 <= n && data[maxIndex] < data[index*2+1] {
			maxIndex = index*2 + 1
		}

		if maxIndex == index {
			break
		}

		data[maxIndex], data[index] = data[index], data[maxIndex]
		index = maxIndex
	}
}

func deleteTop(data []int) {
	lastValue := data[len(data) - 1]
	data = data[0:len(data) - 2]
	data[0] = lastValue
	sink(data, 0)
}
```

## 结论
1. 无论是插入数据还是删除数据，都是堆化的过程
2. 插入元素和删除堆顶元素的时间复杂度为O(logn)

# 堆排序
堆排序简单来说，就是利用堆的性质来进行排序。

堆排序是一种就地排序，在任何时候数组中只有常数个元素存储在输入数组之外。  
时间复杂度为O(nlogn)

我们知道堆的高度为O(logN)，下沉时间顶多为O(logN)，即O(h)，h为堆的高度

将一个无序的数组序列进行堆排序，有两个步骤：
1. 将数组构建成一个满足二叉堆性质的数组，即建堆
2. 对这个二叉堆进行排序，即排序

如果是递增排序，可以采用建立最大堆的方式；如果是递减排序，可以采用建立最小堆的方式。

这里我们做的是递增排序，也即最大堆的方式

另外我们构建的数组中，数据会从下标为1处开始存储，这样方便我们计算父子节点。

## 建堆
建堆是指将数组中的数据最终变成符合堆的特性的顺序，一般采用自底向上的方式来建堆，即从后往前处理数组的数据，不断通过下沉的方式调整数据，建堆的运行时间为O(N)
```go
func buildHeap(data []int) {
	length := len(data)
	for i := length / 2; i >= 1; i-- {
		sink(data, i)
	}
}
```

![WX20180803-135908](../images/WX20180803-135908.png)

这种方式建堆会从n/2开始，而n/2+1到n都是叶子节点，也就相当于我们直接忽略最后一层，从倒数第二层开始建堆。

每个节点堆化中比较和交换的次数和高度成正比。

```
S1 = 1 * h + 2 * (h-1) + 2^2 * (h-2) + ... + 2^k * (h - k) + ... + 2^(h-1) * 1

# 将等式两边都乘以2，得到
S2 =         2 * h    +  2^2 *(h-1) + ... + 2^k * (h - k + 1)... + 2^(h-1) * 2 + 2^(h) * 1

S = S2 - S1 = h + 2 + 2^2 + 2^3 + ... + 2^k + ... + 2^h-1 + 2^h
  = h + (2^h - 2) + 2^h
  = 2^(h+1) + h - 2

h = logn
S = 2^(logn+1) + logn - 2
  = O(n)
```

由此可知，堆化的时间复杂度为O(n)

## 排序
堆化之后的数据，堆顶已经是最大的元素了，这时我们按照如下流程进行元素调整，最终让有元素有序。

排序过程：
1. 将第一个元素和堆的最后一个元素交换，将最后一个元素放到堆顶，必然会引起堆结构被破坏，此时通过下沉方式调整堆结构。
2. 取出此时的堆顶元素，和倒数第二个元素交换，再次调整。这方式有点像在删除元素
3. 不断重复，知道再无元素可以取。此时会构建出一个递增排序的新堆。

简单来说，堆排序是由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。

```go
func sort(data []int) {
	// 堆化
	buildHeap(data)

	length := len(data)
	k := length
	for k > 1 {
		data[1], data[k] = data[k], data[1]
		k--
		sink(data, k, 1)
	}
}
```
运行时间：
构建初始堆+堆元素交换 = O(N) + O(swap)  
堆元素交换运行时间=log(N-1) + log(N-2) + ... + log(1) = O(NlogN)

因此运行时间为 = O(N) + O(NlogN) = O(NlogN)

## 结论
一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

堆排序时一种原地排序，没有利用额外的空间。

我们知道快速排序的时间复杂度也是O(NlogN)，但是在实际使用中，会偏向于使用快速排序，而不是堆排序，这是因为：
1. 堆排序对数据的访问方式不是很友好，没法充分利用CPU缓存。例如我们建堆的过程中，数据都是跳着访问的，如1，2，4，8，但是快排的话，访问都是局部的顺序访问。
2. 对于同样的数据，在排序的过程中，堆排序的数据交换次数要多于快速排序。在建堆的过程中，会打乱数据的有序性，可能会导致本来已经有序的数据，建堆后就变得无序了。

## 堆的应用
### 优先级队列
队列的特性也是先进先出，优先级队列也是一种队列，但它不是先进先出，而是优先级高的先出。

可以采用堆来实现优先级队列，往优先级队列中插入元素，相当于往堆中插入元素，优先级最高的可以从堆顶获取。

优先级队列在很多场合都会用到

#### 定时器队列
项目中经常会使用到定时器，在定时器维护很多定时任务，每个任务都设定了一个时间，到达一定的时间就会执行特定的任务。

定时器需要定时的不断扫描任务，发现到达触发时间就得执行任务，那么如何定时扫描才能更搞笑呢？

最传统的方式就是每隔一个很短的时间，如1s，就扫描所有任务，但是这种方式效率很低，因为有可能大部分任务都还没到时间时间，但是却需要浪费大部分时间来扫描，而且如果列表很大的话扫描也会很耗性能。

我们可以采用优先级队列来解决这个问题，这个优先队列可以是用堆实现的。

先按照任务设定的执行时间，将这些任务存储在优先队列中，队列首部（小顶堆的堆顶）存储的是最先执行的任务。

然后取出队列首部的任务，得到任务执行的时间点，与当前时间做比较，两者的差值为T，那么在这段T时间里，定时器可以不用做任何事情，等到T秒后就开始执行这个队首的任务，将它从队列首部移除，获取新的首部（堆的话，要重新堆化），得到新的时间，同理再和当前时间做比较，计算距离下次执行的时间。

通过这种方式不需要不断每秒轮训队列，而且每次只需要获取一个任务。

#### 合并有序的小文件
假设我们已经有100个小文件，每个文件大小为100MB，每个文件存储的是排好序的字符串。现在想将这100个文件合并成一个有序的大文件。

第一个方法，可以先从100个文件中，都取出第一个元素放入一个数组中，然后获取数组中最小的元素，并且将其从数组移除，然后将它加入大文件中。接下来继续从这个被移除元素所在的小文件中挑选第二个元素，放入数组，重复上述过程。这样最终大文件的就是有序的。

但是这种方式效率太低了，也相对浪费空间一些，我们可以采用优先级队列改善。

同样还是从100个文件中各取出第一个元素，然后构建成一个小顶堆，那么堆顶就是最小的元素，删除堆顶的元素，将其加入大文件中。

调整堆，然后从被删除元素所在的小文件中取出第二个元素，加入堆中，重新调整堆，再删除堆顶的元素，加入大文件中。不断重复这个过程。

这种方式，删除元素和加入元素都各需堆化一次，时间复杂度都为O(logn)，这里的n是堆中的元素，即100。存储空间比用数组的方式得到很大节省。

### 获取TOP K的数据
有一个很大的集合，包含元素n个，如何获取前k大的元素?

1. 先从数组中取出k个元素，然后构造一个小顶堆，堆顶就是k个元素中最小的一个。
2. 遍历数组中剩余的元素，每取出一个元素，和堆顶的元素比较
	* 如果比堆顶元素大，则替换堆顶元素，然后重新下沉堆化
	* 如果比堆顶元素小，则忽略，继续读取数据下一个元素
3. 遍历结束后，堆中的k个元素就是数组中前k大的元素了

性能分析：
1. 遍历数组的时间复杂度为O(n)，进行一次堆化的时间复杂度为O(logk)。
2. 最坏情况下，每取得一个元素都需要替换堆顶元素并且导致堆化，这个时间复杂度为O(nlogn)

对于如果是动态的数据集合，即既有操作不断写入数组中，另外又有操作不断的获取前k大元素。  
1. 依旧先维护一个k个大小的小顶堆
2. 当有新的元素需要被添加到数组时，同时将它和堆顶元素比较
  * 如果比堆顶元素大，则替换堆顶元素，然后重新下沉堆化
  * 如果比堆顶元素小，则忽略，继续读取数据下一个元素
3. 此时，无论何时查询只要返回堆的元素就是前k大元素。