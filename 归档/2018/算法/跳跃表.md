# 跳跃表
跳跃表是基于链表（有序链表）的基础实现的。虽然链表的插入操作很快，只需要O(1)的运行时间，但由于插入前需要做一次查找，而查找时间不是很快需要O(N)，所以也导致插入操作的时间也要O(N)

那么有什么办法可以加快链表的查询时间呢？跳跃表就是其中一种优化方式。  
通过提取链表中的部分元素构成一个新的链表，这样需要查找的元素个数也减少了。
```
关键节点   1-------->3--->5-------->7
          |         |    |         |
          ∨         ∨    ∨         ∨
原始链表   1--->2--->3--->5--->6--->7--->8
```
如上图所示我们将原始链表中的奇数节点作为关键节点。当我们需要查询7的时候只需要在关键节点上查询1、3、5、7就能查找得到，而不需要查找1、2、3、5、6、7这么多节点。  
当我们需要插入4的时候，只需要和7、5、3比较，不需要和8、7、6、5、3比较。然后确定了需要插入在3、5之间时，就可以回到原始链表实行插入操作。

虽然我们增加了50%的空间，但是速率也提高了一倍。不仅如此，我们还可以继续增加层数，让元素变得更少
```
索引2      1------------->5    
          |              |
          ∨              ∨ 
索引1      1-------->3--->5-------->7
          |         |    |         |
          ∨         ∨    ∨         ∨
原始链表   1--->2--->3--->5--->6--->7--->8
```
我们在索引1的基础上，再增加一层索引2，这样让查找时再次缩小范围找到大体范围。  
在提取节点的过程中，我们会尽量让该层节点为上一层节点的一半，直到元素个数为2为止，因为1个元素没有比较的意义。这种多层级的链表结构就是【跳跃表】

当大量新的节点通过一层一层的查找最终插入原始链表后，可能会造成上层的节点不够用，导致需要在原始链表做遍历查找操作
```
索引2      1------------->5    
          |              |
          ∨              ∨ 
索引1      1-------->3--->5-------->7
          |         |    |         |
          ∨         ∨    ∨         ∨
原始链表   1--->2--->3--->5--->6--->7--->8>--->11--->15--->22--->30
```
如上图，当我们需要插入25时，会发现上层的索引几乎没发挥作用，到了原始链表就开始遍历8之后的节点了。该怎么避免这种情况呢？

跳跃表的设计者设计了一种方式，【抛硬币】。通过50%随机的概率来决定被插入的新节点需不需要向上一层提拔。

假设我们需要插入9这个节点
```
索引2      1------------->5    
          |              |
          ∨              ∨ 
索引1      1-------->3--->5-------->7-------->9(再抛硬币，结果是负，不再向上提拔)
          |         |    |         |         |
          ∨         ∨    ∨         ∨         ∨
原始链表   1--->2--->3--->5--->6--->7--->8--->9(抛硬币，结果是正，于是把节点9向上提拔)
```

通过这种抛硬币的方式，可以让跳跃表整体趋于均匀的状态，当然并没办法做到绝对均匀，如果你每次都抛到负，那就没办法了，但是从统计学来说还是趋于均匀的。

如果要删除节点，则很简单，只需要删除原始链表的节点，然后向上逐层删除对应节点即可。如果某一层的节点被删除后只剩下1个节点，则该层数可以被删除。
假设我们要删除5节点
```
索引2      1------------->(5)    
          |               |
          ∨               ∨ 
索引1      1-------->3--->(5)-------->7
          |         |     |         |
          ∨         ∨     ∨         ∨
原始链表   1--->2--->3--->(5)--->6--->7--->8
```
删除后变成
```
关键节点   1-------->3-------->7
          |         |         |
          ∨         ∨         ∨
原始链表   1--->2--->3--->6--->7--->8
```

# 复杂度
新的节点需要和各层的索引逐一比较，直到原始链表，以此确定原始链表的插入位置。  
跳跃表的查找的运行时间是O(logN)

当找到插入位置后，插入原始链表的运行时间和链表一致，为O(1)

通过抛硬币的方式决定元素需不需要向上提拔，最坏情况也是一直上抛h的高度，运行时间也为O(h)，即O(logN)。

由于跳跃表需要额外的空间来构建每一级索引，每一级索引的数据个数都是下级索引个数的一半，因此有：  
n + n/2 + n/4 + ... + 4 + 2 = n - 2  
也就是说，空间复杂度为O(n)。  
虽然我们的链表可能很大，但是索引可以只存储关键值或者几个指针，并不需要存储对象，这个空间损耗基本可以忽略不计。
