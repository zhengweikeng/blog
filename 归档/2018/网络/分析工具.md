# uptime
打印系统平均负载的工具
```bash
$ uptime
15:34  up 13 days,  5:49, 4 users, load averages: 1.72 1.75 1.71
```
最后三个数字代表1、5、15分钟内的平均负载

# vmstat
可对操作系统的虚拟内存、进程、IO读写、CPU活动等进行监视
```bash
$ vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 176820  60436 194776    0    0     0     3    1    0  1  0 99  0  0
```

procs:  
r: 等待运行的进程数，如果该值很大，说明当前CPU非常繁忙。如果该参数长期大于和等于逻辑CPU个数，则CPU资源可能存在较大的瓶颈  
b: 处在非中断睡眠状态的进程数，意味着进程被阻塞。

memory:  
swpd: 已经使用的虚拟内存大小，如果虚拟内存使用较多，可能系统的物理内存比较吃紧，需要采取合适的方式来减少物理内存的使用。  
free: 空闲的物理内存大小  
buff: 用来做buffer（缓存，主要用于块设备）的内存数，单位KB  
cache: 用来做cache（缓存，主要用于缓存文件）的内存数，单位KB

swap:  
si: 从磁盘交换到内存的交换页数量，单位KB/s  
so: 从内存交换到磁盘的交换页数量，单位KB/s  

首先什么是虚拟内存？  
可以简单的认为是把物理内存拿出一部分出来，当内存不够的时候可以顶替它。  

当内存够用的时候，这两个值都是0，这两个值都是0。而如果这两个值长期大于0，系统性能会受影响，磁盘IO和CPU资源都会被消耗。所以我们不能看到空闲内存free为0或者很小就认为内存不够用，还需要结合si和so。如果free很少，但是si和so也很少或者为0，这时系统的性能是不会受到影响的。  
当内存的需求大于RAM的数量，便会启用虚拟内存，虽然这并不能说明目前机器内存出现问题，但是也从侧面反映机器目前对内存的需求比较大。

io:  
bi: 每秒从块设备接收到的块数，单位块/s，也就是读块设备  
bo: 每秒发送到块设备的块数，单位块/s，也就是写块设备

system:  
in: 每秒的中断数，包括时钟中断  
cs: 每秒的环境（上下文）切换次数。比如我们调用系统函数，就要进行上下文切换，而过多的上下文切换会浪费较多的cpu资源，这个数值应该越小越好。

cpu:  
us: 用户CPU时间(非内核进程占用时间)（单位为百分比）。us的值比较高时，说明用户进程消耗的CPU时间多  
sy: 系统使用的CPU时间（单位为百分比）。sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。  
id: 空闲的CPU的时间(百分比)，在Linux 2.5.41之前，这部分包含IO等待时间。  
wa: 等待IO的CPU时间，在Linux 2.5.41之前，这个值为0 .这个指标意味着CPU在等待硬盘读写操作的时间，用百分比表示。wait越大则机器io性能就越差。说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。

# top
```bash
$ top
top - 17:14:36 up 73 days,  1:51,  2 users,  load average: 0.14, 0.05, 0.01
Tasks: 297 total,   1 running, 296 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.9 us,  0.2 sy,  0.0 ni, 98.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:  16432072 total, 16255652 used,   176420 free,    50992 buffers
KiB Swap:        0 total,        0 used,        0 free.   188232 cached Mem

PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
1678 root      20   0 2413932  74268   3068 S   2.0  0.5 639:50.41 java
3328 root      20   0  694436  64036   5040 S   1.0  0.4 568:56.55 PM2 v2.9.1: God
3348 root      20   0 1991552 1.288g   5316 S   0.7  8.2 291:21.11 node /var/works
```

第一行是系统基本信息，如系统时间，已经运行了多少天，其中load average后面的三个值指的是过去1分钟、5分钟、15分钟的负载情况。  
load average的值，除以逻辑cpu的数量后，该值大于5的话就标明系统在超负荷运转

第二行是任务的基本信息，如系统有多少个进程，处于运行的个数，休眠的个数，停止状态的个数还有处于僵尸状态的进程个数

第三行是cpu的情况  
us: 用户空间占用cpu的百分比  
sy: 系统占用cpu的百分比  
id: 空闲的cpu百分比  
wa: 等待IO的CPU占比  
hi: 硬中断（Hardware IRQ）占用CPU的百分比  
si: 软中断（Software Interrupts）占用CPU的百分比

第四行是内存的使用情况，和vmstat的描述一样

第五行内存交换的情况，和vmstat的描述一样，如果值一直处于变化，说明系统内存不够了

第七行以下：各进程（任务）的状态监控
PID: 进程id  
USER: 进程所有者  
PR: 进程优先级  
NI: nice值。负值表示高优先级，正值表示低优先级  
VIRT: 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES  
RES: 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA  
SHR: 共享内存大小，单位kb  
S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程  
%CPU: 上次更新到现在的CPU时间占用百分比  
%MEM: 进程使用的物理内存百分比  
TIME+: 进程使用的CPU时间总计，单位1/100秒  
COMMAND: 进程名称（命令名/命令行）
