# Golang中的条件变量
有时候线程在执行的时候，需要等待某个条件满足一定条件后才能继续执行，否则只能一直的等待阻塞。当另外一个线程在执行过程中，使那个条件成立，就唤醒之前阻塞的那个线程。这就是条件变量的作用。

条件变量有如下几个方法：
1. wait，等待通知
2. signal，单发通知
3. broadcast，广播通知

条件变量必须配合互斥锁一起使用，示例代码如下：

```go
func main() {
	c := sync.NewCond(&sync.Mutex{})
	condition := false

	go func() {
		time.Sleep(time.Second)
		c.L.Lock()
		condition = true
		c.Signal()
		c.L.Unlock()
	}()

	c.L.Lock()
	for !condition {
		c.Wait()
	}
	c.L.Unlock()
}
```

案例中主线程会先进行加锁，然后判断条件是否成立，如果条件不成立则等待（c.Wait()）。  
而对于协程，会等待1秒模拟任务耗时，之后也会加锁，再修改变量使其满足条件，最后发送通知。

条件变量被用来阻塞一个线程，当条件不满足时，线程会解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。

互斥锁和条件变量的区别：
1. 互斥锁体现的是一种竞争，我离开了，通知你进来。
2. 条件变量体现的是一种协作，我准备好了，通知你开始吧。

## Wait的本质和为何Wait前需要加锁？
Wait调用后，线程将阻塞，这意味着线程将睡眠，在它苏醒之前不会消耗 CPU 周期。这正是我们期待发生的情况。线程将一直睡眠，直到特定条件发生，在这期间不会发生任何浪费CPU。从线程的角度来看，它只是在等待wait调用返回。

条件变量的Wait方法其实做了如下四件事：
1. 把调用它的*goroutine*（也就是当前goroutine）*加入*到当前条件变量的*通知队列*中
2. *解锁*当前的条件变量基于的那个*互斥锁*
3. 让当前的*goroutine*处于*等待*状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个wait方法的那行代码上
4. 如果*通知到来*并且决定唤醒这个goroutine，那么就在唤醒它之后*重新锁定*当前条件变量基于的*互斥锁*。自此之后，当前的goroutine就会继续执行后面的代码了

```go
func (c *Cond) Wait() {
	c.checker.check()
	t := runtime_notifyListAdd(&c.notify)
	c.L.Unlock()
	runtime_notifyListWait(&c.notify, t)
	c.L.Lock()
}
```

为了避免多个线程为了Wait进而同时判断条件变量导致竞态发生，因此使用Wait前也必须加锁，成功调用Wait后，Wait内部便可以释放锁。释放锁的原因是为了让其他线程能够加锁进入临界区进而修改变量，之后线程就进入等待。当线程被唤醒后，会重新锁定，这是为了避免有其他线程再次修改变量。

### 为什么条件判断的时候要使用循环而不是if判断？
主要是为了保险起见，如果一个goroutine因收到通知而被唤醒，但却发现共享资源的状态依然不符合它的要求（有可能在Wait里最后一步加锁前又被修改），此时就应该再次进入Wait等待状态，等待下一次通知的到来。
