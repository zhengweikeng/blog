- [复制](#%e5%a4%8d%e5%88%b6)
  - [单领导者（single leader）](#%e5%8d%95%e9%a2%86%e5%af%bc%e8%80%85single-leader)
    - [复制的类型](#%e5%a4%8d%e5%88%b6%e7%9a%84%e7%b1%bb%e5%9e%8b)
    - [新增一个从库](#%e6%96%b0%e5%a2%9e%e4%b8%80%e4%b8%aa%e4%bb%8e%e5%ba%93)
    - [节点宕机处理](#%e8%8a%82%e7%82%b9%e5%ae%95%e6%9c%ba%e5%a4%84%e7%90%86)
      - [从库失效](#%e4%bb%8e%e5%ba%93%e5%a4%b1%e6%95%88)
      - [主库失效](#%e4%b8%bb%e5%ba%93%e5%a4%b1%e6%95%88)
      - [故障转移的影响](#%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb%e7%9a%84%e5%bd%b1%e5%93%8d)
    - [复制日志](#%e5%a4%8d%e5%88%b6%e6%97%a5%e5%bf%97)
      - [基于语句的复制（Statement-based replication）](#%e5%9f%ba%e4%ba%8e%e8%af%ad%e5%8f%a5%e7%9a%84%e5%a4%8d%e5%88%b6statement-based-replication)
      - [预写式日志（Write-ahead log，WAL）](#%e9%a2%84%e5%86%99%e5%bc%8f%e6%97%a5%e5%bf%97write-ahead-logwal)
      - [逻辑日志（基于行）复制](#%e9%80%bb%e8%be%91%e6%97%a5%e5%bf%97%e5%9f%ba%e4%ba%8e%e8%a1%8c%e5%a4%8d%e5%88%b6)
      - [基于触发器的复制](#%e5%9f%ba%e4%ba%8e%e8%a7%a6%e5%8f%91%e5%99%a8%e7%9a%84%e5%a4%8d%e5%88%b6)
    - [复制延迟问题](#%e5%a4%8d%e5%88%b6%e5%bb%b6%e8%bf%9f%e9%97%ae%e9%a2%98)
      - [读自己的写（Reading your own writes）](#%e8%af%bb%e8%87%aa%e5%b7%b1%e7%9a%84%e5%86%99reading-your-own-writes)
      - [单调读（Monotonic Reads）](#%e5%8d%95%e8%b0%83%e8%af%bbmonotonic-reads)
      - [一致前缀读（Consistent Prefix Reads）](#%e4%b8%80%e8%87%b4%e5%89%8d%e7%bc%80%e8%af%bbconsistent-prefix-reads)
  - [多领导者复制（Multi-Leader replication）](#%e5%a4%9a%e9%a2%86%e5%af%bc%e8%80%85%e5%a4%8d%e5%88%b6multi-leader-replication)
    - [多主复制使用场景](#%e5%a4%9a%e4%b8%bb%e5%a4%8d%e5%88%b6%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af)
      - [运维多个数据中心](#%e8%bf%90%e7%bb%b4%e5%a4%9a%e4%b8%aa%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83)
      - [需要离线操作的客户端](#%e9%9c%80%e8%a6%81%e7%a6%bb%e7%ba%bf%e6%93%8d%e4%bd%9c%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af)
      - [协同编辑](#%e5%8d%8f%e5%90%8c%e7%bc%96%e8%be%91)
    - [处理写入冲突](#%e5%a4%84%e7%90%86%e5%86%99%e5%85%a5%e5%86%b2%e7%aa%81)
      - [同步与异步冲突检测](#%e5%90%8c%e6%ad%a5%e4%b8%8e%e5%bc%82%e6%ad%a5%e5%86%b2%e7%aa%81%e6%a3%80%e6%b5%8b)
      - [避免冲突](#%e9%81%bf%e5%85%8d%e5%86%b2%e7%aa%81)
      - [收敛至一致的状态](#%e6%94%b6%e6%95%9b%e8%87%b3%e4%b8%80%e8%87%b4%e7%9a%84%e7%8a%b6%e6%80%81)
      - [自定义冲突解决](#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%86%b2%e7%aa%81%e8%a7%a3%e5%86%b3)
  - [无领导者（Leaderless replication）](#%e6%97%a0%e9%a2%86%e5%af%bc%e8%80%85leaderless-replication)
    - [当节点故障时写入数据库](#%e5%bd%93%e8%8a%82%e7%82%b9%e6%95%85%e9%9a%9c%e6%97%b6%e5%86%99%e5%85%a5%e6%95%b0%e6%8d%ae%e5%ba%93)

# 复制
三种流行的更变复制算法：
1. 单领导者（single leader）
2. 多领导者（multi leader）
3. 无领导者（leaderless）

## 单领导者（single leader）
副本：存储数据库副本的每个节点都称为副本（replica）。复制要解决的就是如何确保数据都正确的落在所有的副本上。

单领导者的复制（leader-based replication），就是我们常说的主从（master/slave）复制，复制流程：
1. 选择其中一个副本作为领导者，即我们常说的主库（master），客户端发送的写入操作都是发给主库。
2. 其他的副本都称为追随者，即我们常说的从库（slave），每当主库有新数据写入主库时，主库也要将数据变更发送给所有从库，称之为复制日志（replication log）记录或变更流（change stream）。每个追随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。
3. 查询数据时可从领导者（主库）拉取，也可以从追随者（从库）拉取。但是领导者只能接受写入。

### 复制的类型
复制分为两种：
1. 同步（synchronous）复制，主库接收到请求处理结束后，发送所有变更到所有从库，从库全部完成更新后会通知主库，主库接收到所有通知后，返回客户端请求成功。
2. 异步（asynchronous）复制，主库接收到请求处理结束后，发送所有变更到所有从库，同时会告知客户端处理成功，不需要等待从库的通知。

同步复制的优点：可以保证主库和从库数据都是一致的。即使主库突然失效，任何一个从库都可以立马升级为主库。  
同步复制的缺点：如果同步从库没有响应（例如网络故障），主库需要阻止所有写入操作，并等待同步副本再次可用，客户端的响应也会较慢。

异步复制的优点：不需要关心从库的状态，响应速度快   
异步复制的缺点：可能会有数据延迟，即主库写入了数据，从库还没有同步到，导致主从不一致。

什么是半同步（semi-synchronous）？  
即不将所有从库设置为同步复制的方式，而是只选取部分副本节点和主节点进行同步复制，其他节点采取异步复制。

### 新增一个从库
将一个库设置为从库，为了能与主库的数据保持一致，过程如下：
1. 获取某个时刻主库的一致性快照，这过程并不需要锁上整个数据库。如果你的数据库有定时备份，这个快照很容易拿到。
2. 将快照复制到新的从库节点，从库根据这个快照恢复数据。
3. 从库连接到主库后，拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。例如mysql的快照日志binlog中会记录日志点（position）。
4. 从库处理完快照之后的数据变更后，就说明从库已经赶上主库了，现在可以继续处理主库上产生的数据变化了。

### 节点宕机处理
#### 从库失效
从库失效，奔溃重启后，只需要重新连接上主库后，通过主库日志文件即可知道从库处理的最后一个事务，继续拉取后续的所有变更数据即可，最终能赶上主库。

#### 主库失效
主库失效，过程比较复杂，需要做故障转移（failover）。将其中一个从库升级为新的主库，其他从库也需要修改新的主库地址，而客户端也需要修改主库的地址，以便将写操作发给新的主库。  
可以采用人工手动的方式来进行故障转移（例如通知管理员主库挂了），自动的方式一般步骤如下：
1. 确认主库失效。一般会给节点设置超时时间
2. 选择一个新的主库。可以通过一些选举算法来完成，这是一个共识过程。
3. 重新配置系统一启用新的主库。不仅写请求要发送给新主库，而旧的主库重启后也要知道自己已经成为一个从库了。

#### 故障转移的影响
故障转移会带来一些负面影响：
1. 如果使用异步复制，从库可能还没收到老主库宕机前最后的写入操作。这时从库升级为新主库后，当老主库重新连接上加入集群后，会发现和新主库的数据是冲突的。一般的处理是丢弃老主库的这个写入。
2. 丢弃老主库中和新主库冲突的数据，有时候是很危险的，有可能其他一些依赖的系统早已经写入该数据，例如数据已经写入redis作为缓存并且被外界使用。
3. 有可能会出现两个节点都认为自己是主库的情况，即闹裂（split brain）,这时候需要能够识别到这种情况，并且关闭其中一个。
4. 超时时间如果设置不合理，会出现无意义的故障转义。

### 复制日志
基于主库（leader-based）的复制，底层的实现方式有几种。

#### 基于语句的复制（Statement-based replication）
主库记录每个写入请求的日志，并将给日志发送给所有从库。例如mysql的insert、update和delete语句。从库收到后再次执行语句即可。

有几个问题需要注意：
1. 非确定性（nondeterministic）函数的语句的调用，例如`now()`函数，可能会导致在不同副本上生成不同的值。一般可以将这种不确定值替换为确定的值，例如修改日志中sql语句中的now为主库产生的时间。
2. 语句如果使用了自增列（auto increment），或者依赖于数据库中的现有数据（例如update ... where <条件>），这需要要求每个副本的数据都和主库一模一样，否则可能会导致运行结果的不一致。
3. 有一些语句是有副作用的（例如触发器、存储过程），可能会在每个副本上产生不同的副作用，除非这种副作用是确定的。

对于mysql来说，当语句遇到不确定的时候，mysql会切换到基于行的复制。

#### 预写式日志（Write-ahead log，WAL）
在写入数据前，先记录写入操作的日志，之后数据库再去读取日志将其应用到数据库系统中。一般来说日志中会有两种：
1. redo（重做日志），每当有操作的时候，在数据变更前将操作写入redo log中，这样当发生掉电之类的情况时系统可以在重启后继续操作。
2. undo（撤销日志），当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。

为什么需要使用WAL，然后包含redo和undo信息呢？举个例子，如果一个系统直接将变更应用到系统状态中，那么在机器掉电重启之后系统需要知道操作是成功了，还是只有部分成功或者是失败了（为了恢复状态）。如果使用了WAL，那么在重启之后系统可以通过比较日志和系统状态来决定是继续完成操作还是撤销操作。

mysql中则采用了WAL的机制来实现事务的提交。在提交一个事务的时候，innodb引擎会先写redo log，而且这个过程是顺序写，直接追加在文件后面，所以速度比较快。当写完日志后，也会去更新内存中对应的数据（如果有的话），结束后事务就算成功提交了。此时的内存和磁盘中的数据是不同的，引擎再选择合适的实际将内存的数据刷回磁盘。

#### 逻辑日志（基于行）复制
这种日志，会采用和存储引擎不同的日志格式，使得日志可以从存储引擎内部分离出来。

关系数据库的逻辑日志会通常是以行的粒度描述对数据库表的写入的记录序列：
1. 对于插入的行，日志包含所有列的新值
2. 对于删除的行，日志包含足够的信息来唯一标识已删除的行，一般是主键，如果没有主键，则需要记录所有列的旧值。
3. 对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或者至少所有已更改的列的新值）。

逻辑日志和存储引擎的日志内部分离，可以更容易的保持向后兼容，从而使领导者和跟随者能够运行不同版本的数据库甚至不同的存储引擎。

#### 基于触发器的复制
通过触发器，在数据库系统发生数据更改的时候将数据存储到其他表中，外部程序读取这个表，再加上任何业务逻辑处理，会后将数据变更复制到另外一个系统中去。

触发器的复制通常比其他复制方法具有更高的开销，也更容易出错，也有很多限制。但是由于灵活性，还是有用的。

### 复制延迟问题
从节点在复制主节点的数据，就会有出现延迟的情况。一旦从节点数据落后于主节点，每个从节点同步数据的进度不一致，客户端查询只查从节点的话，就可能查询到不同的结果。而如果停止主库的写入，那么从节点最终会赶上主节点，从而达到一致性。这种就被称为最终一致性（eventually consistency）。

#### 读自己的写（Reading your own writes）
用户写入数据后（主节点负责写入），立马进行查询操作（读取操作只由从节点负责），此时从节点由于复制延迟，可能还没将数据同步过来，用户查询不到写入的数据，用户会觉得很奇怪。

为了实现读后一致性（read-after-write consistency），则需要读自己的写（read-your-writes consistency），即读取自己的数据时，要查询到自己的更新，其他用户的并不关心。

实现的方式有：
1. 从主库读取用户自己的数据，在从库中读取其他用户的数据。
2. 跟踪上次的更新时间，在上次更新后的1分钟内，从主库读。也可以监控从库的复制延迟，防止任何向滞后超过1分钟的从库读取的操作。
3. 客户端记录最近一次写入的时间戳，系统需要确保从库为该用户提供任何查询时，该时间戳前的变更都已经传播到了本从库中。如果该从库不够新，则需要从另一个从库中读取，或者等待从库追赶上来。这个时间戳可以是逻辑时间戳（指示写入顺序的东西，如日志序列号）或者实际系统时间。
4. 如果副本分布在多个数据中心（读取时读取了离自己较近的数据中心），需要由领导者提供服务的请求都必须路由到包含主库的数据中心。

#### 单调读（Monotonic Reads）
复制延迟的时候，有时还会遇到时光倒流的情况。先从一个延迟较小的从库读取，再从一个延迟较大的从库读取，第一次读到了一条数据，第二次可能就会没看到这条数据，例如用户第一次查看了一条评论，刷新再看的时候就消失了。如果第一次没读到，第二次读到了，倒没什么影响。

这时候需要单调读来解决，它是一种比强一致性（Strong consistency）弱，但比最终一致性强的保证。

只需要确保每个用户每次都从同一个从库读取即可，不同的用户则读取不同的从库。这样前后读取到的内容就是一致的。例如可以根据用户id的散列来选择从库。

#### 一致前缀读（Consistent Prefix Reads）
复制延迟还可能导致前因后果出错，例如两个人查询聊天记录，顺序是AB，然后第三个人读取的时候，分别从一个较延迟和严重延迟的从库中读取，先读取到了B，再读取到了A，前因后果出现了错乱。

这需要一致前缀读来解决，即一系列写入是按某个顺序发生的，那么任何人读取的时候，应该也要按照这个顺序被读取出来。

只需要确保任何因果相关的写入都写入到相同的数据库分区中。

## 多领导者复制（Multi-Leader replication）
多领导复制模式下，多个节点同时负责写入操作，节点在写入数据之后必须将数据转发给所有其他节点。这种模式也称为多主、多活复制。

### 多主复制使用场景
#### 运维多个数据中心
如果采用之前的单领导者的模式，主库只能存在于其中一个数据中心，其他数据中心都是从库。而多主模式下，每个数据中心都有主库，每个数据中心的数据变更都会将其复制到其他数据中心的主库。

单领导者和多领导者的比较：  
1. 在**性能**上，单领导者下主库存在于一个数据中心，对于用户来说写操作时要数据要穿过互联网进入该数据中心，耗时较长；而对于多领导者，用户可以选择就近的数据中心来写入数据，并异步的将数据复制给其他数据中心，数据中心的网络延迟对用户来说是透明的。
1. 多主模式下，能够**允许数据中心停机**。在单领导者下，主库所在的数据中心停机，需要进行故障转移，将其他数据中心的从库升级为主库，这个过程会比较复杂和且容易出现错误；在多活配置下，有数据中心发生停机，可以切换使用其他数据中心，不影响数据的操作，当故障的数据中心恢复时，数据会被复制到原来故障的数据中心。
1. 多活配置还能很好的**容忍网络问题**。单领导者下，写操作要穿过互联网进入主库所在的数据中心，这可能不如数据中心内本地的网络可靠；多领导者则更能承担网络问题，临时的网络中断并不会妨碍正在处理的写入。

多主复制的缺点：两个数据中心可能会同时修改相同的数据，即写冲突。

#### 需要离线操作的客户端
有些设备即使在网络断开的情况下也要能继续工作，例如备忘录或者日记，在网络断开的这段时间，能够继续进行本地编辑。这个时候要求客户端本地也有个数据库，记录所有的变更操作。等到网络恢复后，需要将所有更改同步到服务器。这个过程也是个多主异步复制的过程。

#### 协同编辑
实时协同软件允许多个人同时进行文档编辑。每个人编辑文档后会存储到本地的数据库，并异步复制到服务器和编辑同一文档的任何其他用户。

如果是单领导复制，则其中一个用户在编辑时需要锁定其他用户的文档，等到他提交时才释放锁定。而多领导复制则不会进行锁定，允许多个用户同时编辑，只是需要去处理冲突。

### 处理写入冲突
多主复制经常会有冲突，即多个主节点都对同一个数据进行更新，如何处理这个冲突非常关键。

#### 同步与异步冲突检测
将冲突检测同步，即在等待所有写入操作都被复制到其他副本后再告诉用户写入成功。但是这样会失去多主复制的优点，即无法让每个副本都独立接受写入。

异步冲突检测就是在稍后的时间点仅仅异步地检测到冲突，那要求用户解决冲突可能为时已晚。

#### 避免冲突
应该想办法避免冲突。例如在用户编辑自己的数据时，可以确保来自特定用户的请求始终路由到同一数据中心，并且使用该数据中心的领导者进行读写。

但有可能指定的数据中心停机了，或者用户迁移了，离另外一个数据中心更近，此时可能还是需要处理冲突。

#### 收敛至一致的状态
数据库需要以一种收敛的方式解决冲突，即所有副本必须在所有变更复制完成时收敛至一个相同的最终值，有几种方式：
1. 给每个写入一个唯一的ID（如时间戳或者UUID），挑选最高ID的写入作为胜利者，并丢弃其他写入。这种几乎被称之为最后写入胜利（LWW，last write wins），但这种方法容易造成数据丢失。
2. 为每个副本分配一个唯一的ID，ID编号更高的写入具有更高的优先级，但也会造成数据丢失。
3. 以某种方式将这些值合并在一起。
4. 在保留所有信息的显示数据结构中记录冲突，并编写解决冲突的程序代码（也可以通过提示用户的方式）。

#### 自定义冲突解决
通过应用程序代码编写冲突解决逻辑来解决多主复制带来的冲突问题，可以在写入或者查询时执行。
1. 写入执行，只要数据库系统检测到复制更改日志存在冲突，就会调用冲突处理程序。
2. 读时执行，所有冲突写入被存储，下一次读取数据时，会将这些多个版本的数据返回给应用程序，提示用户或者自动解决冲突，并将结果返回数据库。

## 无领导者（Leaderless replication）
无领导模式下的数据库，没有主库的概念，允许任何副本直接接受来自客户端的写入，即客户端会将写入直接发送到几个副本中。

### 当节点故障时写入数据库
由于客户端写入的数据时候，要将数据都写入所有副本数据库，假设其中有一个数据库发生故障，就会造成数据的不一致。

假设有一个客户端要将数据写入3个数据。客户端将写入操作`set key=a value=123`并发的发送到3个数据库，db1、db2都是正常的返回，而db3因发生故障报错，此时db1和db2的数据是一致的，而db3是不一致的。

需要通过一些方式来修复这种不一致的问题。
1. 读修复（Read repair）。在客户端并行读取多个节点时候，遇到有节点返回旧的数据时，用正常节点的数据去覆盖旧版本的数据。
2. 反熵过程（Anti-entropy process）。通过一个后台进程，不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本，这个过程会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。
